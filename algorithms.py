from utils import *
import math
import random
import time
from scipy.optimize import fsolve
import copy
import numpy as np
import multiprocessing

class Attraction_algorithm():
    def __init__ (self, cell_list, d, NFZ_edges, initial_energies, number_uavs, initial_positions, pod):
        self.valid_cell_list = [cell for cell in copy.deepcopy(cell_list) if cell.status == 1]
        self.NFZ_edges = NFZ_edges
        self.number_uavs = number_uavs
        self.paths = [[] for i in range(number_uavs)]
        self.paths_idx = [[] for i in range(number_uavs)]
        self.initial_positions = initial_positions
        self.initial_energies = initial_energies
        self.turn_weight = 0.0173
        self.distance_weight = 0.1164
        self.d = d
        self.pod = pod
        
    def attraction(self, cell1, cell2):
        """Quantifies the attraction generated by cell2 on cell1"""
        distance = math.sqrt((cell2.x - cell1.x)**2 + (cell2.y - cell1.y)**2)
        #attraction = cell2.poc*cell2.not_covered/math.exp(distance/self.d)
        
        #attraction = cell2.poc*cell2.not_covered/(distance/self.d)
        
        #bad initial guess
        #attraction = cell2.poc*cell2.not_covered*math.exp(-0.1*distance/self.d)
        
        #New attraction calculation
        pos_cummulative = (1-self.pod)**cell2.times_covered_prev*self.pod*cell2.poc
        
        attraction = pos_cummulative*math.exp(-0.1*distance/self.d)
        
        return attraction
    
    def calc_movement_dir(self, cell1):
        # Finds the cell that produces the biggest attraction
        max_att = 0
        for idx, cell2 in enumerate(self.valid_cell_list):
            if cell1.i != cell2.i or cell1.j != cell2.j:
                att = self.attraction(cell1,cell2)
                if att> max_att:
                    max_att = att
                    max_cell = cell2
                    max_idx = idx
        #If all the cells have been visited, the max attraction is 0
        if max_att == 0:
            return 0
        # Performs graph search to find the best path to it
        traj_prob = TrajectoryProblem(self.valid_cell_list, cell1, max_cell)
        solution, path = traj_prob.solve()
        #plot the path
        #x_coords = [node.state.x for node in path]
        #y_coords = [node.state.y for node in path]
        #plt.plot(x_coords, y_coords, 'y-')
        #plt.plot(x_coords[0], y_coords[0], 'o', color='y')
        #plt.show()
        # Takes a step in the direction that the path specifies
        return solution[0]
    
    def get_next_cell(self, cell):
        solution = self.calc_movement_dir(cell)
        if solution == 0: #all the cells have been visited
            return None, None
        #print(solution)
        idx, next_cell = search_for_cell_ij(self.valid_cell_list, cell.i+solution[1],cell.j+solution[2])
        next_cell.prev_action = solution
        #if idx == None:
            #stays in place because it tried to leave the map
            #idx, next_cell = search_for_cell_ij(self.valid_cell_list, cell.i,cell.j)
        return idx, next_cell
    
    def generate_uav_path(self):
        stopped_uavs = []
        for uav in range(self.number_uavs):
            if len(self.initial_positions) != 0:
                idx, initial_cell = search_for_cell_ij(self.valid_cell_list, self.initial_positions[uav][0], self.initial_positions[uav][1])
            else:
                available_pos = [[cell.i,cell.j] for cell in self.valid_cell_list]
                initial_pos = random.choice(available_pos)
                idx, initial_cell = search_for_cell_ij(self.valid_cell_list, initial_pos[0], initial_pos[1])
            #idx = random.randint(0, len(self.valid_cell_list)-1)
            #initial_cell = self.valid_cell_list[idx]
            cell = copy.deepcopy(initial_cell)
            cell.prev_action = ('FIRST', 0, 0)
            self.paths[uav].append(copy.deepcopy(cell))
            #self.valid_cell_list[idx].not_covered = 0
            self.valid_cell_list[idx].times_covered_prev += 1
            self.paths_idx[uav].append(idx)
            stopped_uavs.append(0)
        #print("Current cell: ", cell.i, cell.j)
        energies_rem = copy.deepcopy(self.initial_energies)
        uav = 0
        while(1):
            if all(stopped_uavs):
                counter += 1
                if counter == self.number_uavs:
                    break
            else:
                counter = 0
            if uav == self.number_uavs:
                uav = 0
            cell = self.paths[uav][-1]
            idx, next_cell = self.get_next_cell(cell)
            if idx == None: #all the cells have been visited
                break
            else:
                turn = calculate_turn_from_actions(cell.prev_action, next_cell.prev_action)
                distance = math.sqrt((next_cell.x - cell.x)**2 + (next_cell.y - cell.y)**2)
                energy_necessary = self.turn_weight*turn + self.distance_weight*distance
                if energies_rem[uav] > energy_necessary:
                    energies_rem[uav] -= energy_necessary
                    self.paths[uav].append(copy.deepcopy(next_cell))
                    self.valid_cell_list[idx].times_covered_prev += 1
                    self.paths_idx[uav].append(idx)
                    stopped_uavs[uav] = 0
                else:
                    stopped_uavs[uav] = 1
            #cell = copy.deepcopy(next_cell)
            #print("Current cell: ", cell.i, cell.j)
            uav += 1
    
    def calculate_turn(self, cell1, cell2, cell3):
        """Calculate the degrees involved in turing from cell1, 2 and 3"""
        vec1 = np.array([cell2.x-cell1.x, cell2.y-cell1.y])
        vec2 = np.array([cell3.x-cell2.x, cell3.y-cell2.y])
        cos_angle = np.dot(vec1, vec2)/(np.linalg.norm(vec1)*np.linalg.norm(vec2))
        cos_angle = round(cos_angle,4)
        angle = np.arccos(cos_angle)/np.pi*180
        return angle #in degrees
    
    """
    def evaluate_path(self):
        #Calculates the overall distance covered, as well as the turns performed
        distance = 0
        turns = 0
        for idx in range(len(self.path)-1):
            distance = distance + math.sqrt((self.path[idx+1].x - self.path[idx].x)**2 + (self.path[idx+1].y - self.path[idx].y)**2)
            
        for idx in range(len(self.path)-2):
            turns = turns + self.calculate_turn(self.path[idx], self.path[idx+1], self.path[idx+2]) #in degrees7

        turn_weight = 0.0173
        distance_weight = 0.1164
        print("Path distance: ", "{:.1f}".format(distance))
        print("Turns (deg): ", "{:.1f}".format(turns))
        print("Energy expended (kJ): ", "{:.1f}".format(turn_weight*turns+distance_weight*distance))
    """
                
    def run_algorithm(self, save_fig=0, fig_name=''):
        
        #Select a random starting point
        #random.seed(time.time())
        #rand_main_cell = random.choice(self.valid_cell_list)
        #print(rand_main_cell.i, rand_main_cell.j)
        
        #Get the cell with the max attraction
        #max_poc = 0
        #for cell in self.valid_cell_list:
        #    if max_poc < cell.poc:
        #        max_poc = cell.poc
        #        max_cell = cell
        #self.generate_uav_path([max_cell.i, max_cell.j])
        #self.generate_uav_path([6, 5])
        #self.generate_uav_path([2, 1])
        self.generate_uav_path()
        
        if save_fig==1:
            f = open('./tese/code/result_images/' + fig_name+'.txt', "a")
            f.write("Using attraction algorithm\n")
            f.write("Path: " + str(self.paths_idx) + '\n')
            f.close()
        #self.evaluate_path()       
        

class SimulatedAnnealing_v2():
    """Using Cooling in Polynomial time from chapter 1 if the Handbook of Metaheuristics"""
    def __init__ (self, cell_list, d, type_init, number_threads, synchronism, initial_energies, number_uavs, initial_positions, pod, fixed_initial_positions = False):
        self.number_threads = number_threads
        self.number_uavs = number_uavs
        self.initial_positions = initial_positions
        self.fixed_initial_positions = fixed_initial_positions
        if number_threads <= 0:
            print("The number of threads must be a positive integer")
            exit()
        manager = multiprocessing.Manager()
        self.threads_paths = [manager.list([manager.list() for i in range(number_uavs)]) for i in range(number_threads)]
        #self.threads_paths = [[] for i in range(number_threads)]
        self.threads_paths_energy = multiprocessing.Array('f', [0 for i in range(number_threads)])
        self.threads_process_time = multiprocessing.Array('f', [0 for i in range(number_threads)])
        self.threads_time = multiprocessing.Array('f', [0 for i in range(number_threads)])
        self.thread_iteration = multiprocessing.Array('i', [0 for i in range(number_threads)])
        self.thread_last_update_iteration = multiprocessing.Array('i', [0 for i in range(number_threads)])
        self.synchronism = synchronism
        self.type_init = type_init
        self.initial_guess_list = []
        self.valid_cell_list = [cell for cell in cell_list if cell.status == 1]
        self.path = []
        self.d = d
        self.initial_energies = initial_energies
        self.adj_dict = {idx:[] for idx in range(len(self.valid_cell_list))}
        self.factor = 0.01
        self.turn_weight = 0.0173
        self.distance_weight = 0.1164
        self.min_energy = self.distance_weight * self.d
        self.L_k = 1000
        self.neighbour_cases = [1,2,3,4,5]
        self.pod = pod
        #Minimum length of the Markov chain
        #self.L_k_min = 500
        #Expected neighbourhood size due to removing, changing and adding nodes, respectively
        #max_steps = self.initial_energy/self.min_energy
        #self.L_k = math.ceil(1*(max_steps) + 3*(max_steps+1) + 4*(max_steps))
        #if self.L_k < self.L_k_min:
        #    self.L_k = self.L_k_min
        
        if type_init == 0:
            #Use attraction path as initial guess
            self.initial_temp = 0.0004
            self.cooling_factor = 0.99
            self.final_temp = 2.755e-6
        elif type_init == 1:
            #Use random walk as initial guess
            self.initial_temp = 0.0085
            self.cooling_factor = 0.99
            self.final_temp = 2.755e-6
        
        self.create_adjacency_dict()
        self.calculate_initial_guess(cell_list, initial_energies, number_uavs, initial_positions)
        
        #We can calculate the initial temperature based on the acceptance rate
        #self.initial_temp = 0
        #self.accept_rate = 0.8
        self.delta = 0.5
        #self.stop_criteria = 0.05
        #The cooling factor is usually between 0.8 and 0.99
        self.my_lock = multiprocessing.Lock()
        self.threads_finished_loop_cond = multiprocessing.Condition(lock=self.my_lock)
    
    def create_adjacency_dict(self):
        """Fills in a dictionary with keys as cells indexes and values as a list of indexes of adjacent cells"""
        #Using 8 connected definition
        for idx1 in range(len(self.valid_cell_list)):
            for idx2 in range(idx1+1, len(self.valid_cell_list)):
                if check_if_cells_adjacent_8_conn(self.valid_cell_list[idx1], self.valid_cell_list[idx2]):
                    self.adj_dict[idx1].append(idx2)
                    self.adj_dict[idx2].append(idx1)
        #Create the dictionary entre for the first virtual node
        self.adj_dict[-1] = [idx for idx in range(len(self.valid_cell_list))]
    
    def calculate_initial_guess(self, cell_list, initial_energies, number_uavs, initial_positions):
        if self.fixed_initial_positions:
            if self.type_init == 0:
                #Use attraction path as initial guess
                att = Attraction_algorithm(cell_list,self.d,[], initial_energies, number_uavs, initial_positions, self.pod)            
                att.generate_uav_path()
                for i in range(self.number_threads):
                    self.initial_guess_list.append(att.paths)
            elif self.type_init == 1:
                for i in range(self.number_threads):
                    #Use random walk as initial guess
                    aux_paths = []
                    for j in range(number_uavs):
                        #random.seed(i)
                        aux_paths.append(self.random_walk_initial_guess(initial_energies[j], initial_positions[j]))
                    self.initial_guess_list.append(aux_paths)
                #random.seed(time.time())
        else: #Use random initial positions
            #The best results might be obtained by deploying close to the suspected target positions or the areas with the most density of probability
            for i in range(self.number_threads):
                #random.seed(i)
                #choose the deployment points based on the POC of the cells
                available_pos = [[cell.i,cell.j] for cell in self.valid_cell_list]
                initial_pos = random.choices(available_pos, weights = [cell.poc for cell in self.valid_cell_list], k = number_uavs)
                #initial_pos = random.choices(available_pos, k = number_uavs)
                if self.type_init == 0:
                    #Use attraction path as initial guess
                    att = Attraction_algorithm(cell_list,self.d,[], initial_energies, number_uavs, initial_pos, self.pod)            
                    att.generate_uav_path()
                    self.initial_guess_list.append(att.paths)
                elif self.type_init == 1:
                    #Use random walk as initial guess
                    aux_paths = []
                    for j in range(number_uavs):
                        aux_paths.append(self.random_walk_initial_guess(initial_energies[j], initial_pos[j]))
                    self.initial_guess_list.append(aux_paths)
            #random.seed(time.time())
    
    def random_walk_initial_guess(self, initial_energy, initial_cell_pos):
        step_distance = 0
        step_turns = 0
        energy_consumed = 0
        idx, aux = search_for_cell_ij(self.valid_cell_list, initial_cell_pos[0],initial_cell_pos[1])
        path = []
        while energy_consumed < initial_energy:
            path.append(self.valid_cell_list[idx])
            idx = random.choice(self.adj_dict[idx])
            step_distance = math.sqrt((path[-1].x - self.valid_cell_list[idx].x)**2 + (path[-1].y - self.valid_cell_list[idx].y)**2)
            if len(path) >= 2:
                step_turns = calculate_turn(path[-2], path[-1], self.valid_cell_list[idx]) #in degrees
            energy_consumed = energy_consumed + self.turn_weight*step_turns + self.distance_weight*step_distance
        return path
    
    
    def calculate_energy(self, paths):
        return -calculate_objective_multi(self.valid_cell_list, paths, self.pod, self.factor)
    
    def calculate_initial_temperature(self, initial_path):
        m_0 = 1000
        m_1 = 0
        m_2 = 0
        delta_f_list = []
        energy= self.calculate_energy(initial_path)
        for i in range(m_0):
            candidate = self.get_random_neighbour(initial_path)
            #Calculate the energy of this new path
            energy_new = self.calculate_energy(candidate)
            #If the new path is better, accept it, and if it is worse dont
            if energy_new < energy:
                m_1 += 1
            else:
                delta_f_list.append(energy_new-energy)
                m_2 += 1
        delta_f_avg = sum(delta_f_list)/len(delta_f_list)
        #print(m_2/(m_2*self.accept_rate - m_1*(1-self.accept_rate)))
        initial_temp = delta_f_avg/(math.log(m_2/(m_2*self.accept_rate - m_1*(1-self.accept_rate))))
        print("Initial temperature: ", initial_temp)
        return initial_temp
        
    def prob_accept(self, delta_E, T):
        #Note: delta_E < 0
        return math.exp(delta_E/(T))
    
    def remove_node_mid(self, candidate):
        #Find a random node in the path
        if not self.fixed_initial_positions:
            aux = list(range(0,len(candidate)))
        else:
            aux = list(range(1,len(candidate)))
        random.shuffle(aux)
        while aux:
            idx = aux.pop()
            #If the selected node is the last OR if the selected node is the first and the initial position can be changed, remove it
            if idx == len(candidate)-1 or idx == 0:
                removed_cell_idx = candidate.pop(idx)
                return candidate
            #Check if the prev and next nodes are adjacent
            elif candidate[idx-1] in self.adj_dict[candidate[idx+1]]: #check_if_cells_adjacent_8_conn(self.valid_cell_list[candidate[idx-1]], self.valid_cell_list[candidate[idx+1]]):
                removed_cell_idx = candidate.pop(idx)
                return candidate
        return candidate
    
    def change_node_position(self, candidate):
        #Try different indexes until one is changed
        if not self.fixed_initial_positions:
            aux = list(range(0,len(candidate)))
        else:
            aux = list(range(1,len(candidate)))
        random.shuffle(aux)
        while aux:
            idx = aux.pop()
            #In case the node selected to change is the last
            if idx == len(candidate)-1:
                neighbours = copy.deepcopy(self.adj_dict[candidate[idx-1]])
                neighbours.remove(candidate[idx])
                if len(neighbours) != 0:
                    #Get a different final node and add it to the path
                    next_cell_idx = random.choice(neighbours)
                    candidate[idx] = next_cell_idx
                    return candidate
            #In case the node selected to change is in the start
            elif idx == 0:
                neighbours = copy.deepcopy(self.adj_dict[candidate[idx+1]])
                neighbours.remove(candidate[idx])
                if len(neighbours) != 0:
                    next_cell_idx = random.choice(neighbours)
                    candidate[idx] = next_cell_idx
                    return candidate
            #In case the node selected to change is in the middle
            else:
                #Get common neighbours between prev and next nodes
                neighbours_prev = self.adj_dict[candidate[idx-1]]
                neighbours_next = self.adj_dict[candidate[idx+1]]
                neighbours = [i for i in neighbours_prev if i in neighbours_next]
                #if candidate[idx] not in neighbours:
                #    print(candidate[idx-1], candidate[idx], candidate[idx+1])
                #    coords = [(self.valid_cell_list[step].i, self.valid_cell_list[step].j)  for step in [candidate[idx-1], candidate[idx], candidate[idx+1]]]
                #    print(coords)
                #    print(neighbours)
                #else:
                neighbours.remove(candidate[idx])
                if len(neighbours) != 0:
                    next_cell_idx = random.choice(neighbours)
                    candidate[idx] = next_cell_idx
                    return candidate
        return candidate

    def add_node_mid(self, candidate):
        #Find a random node in the path
        aux = list(range(0,len(candidate)-1)) #The selected node cant be the last since this one will probably be deleted
        random.shuffle(aux)
        while aux:
            idx = aux.pop()
            #Get common neighbours between prev and next nodes
            neighbours_prev = self.adj_dict[candidate[idx]]
            neighbours_next = self.adj_dict[candidate[idx+1]]
            neighbours = [i for i in neighbours_prev if i in neighbours_next and i != candidate[idx] and i != candidate[idx+1]]
            #print(neighbours)
            if len(neighbours) != 0:
                next_cell_idx = random.choice(neighbours)
                candidate.insert(idx+1, next_cell_idx)
                return candidate
        return candidate
    
    def change_initial_position(self, candidate, uav):
        if self.fixed_initial_positions:
            return candidate
        
        #Change the initial position to any of the cells in the path
        new_start = random.choice(range(1,len(candidate[uav])))
        neighbour = copy.deepcopy(candidate[uav][new_start:])
        neighbour = self.adjust_path_batt(neighbour, uav)
        candidate[uav] = neighbour
        return candidate
    
    def add_node_end(self, candidate, energy_available):
        #print(self.min_energy)
        #print("energy_available: ", energy_available)
        if energy_available <self.min_energy:
            return candidate
        adj_sorted = copy.deepcopy(self.adj_dict[candidate[-1]])
        adj_sorted = sorted(adj_sorted, key = lambda x: self.valid_cell_list[x].poc, reverse = True)
        for cell_idx in adj_sorted:
            distance = math.sqrt((self.valid_cell_list[cell_idx].x - self.valid_cell_list[candidate[-1]].x)**2 + (self.valid_cell_list[cell_idx].y - self.valid_cell_list[candidate[-1]].y)**2)
            if len(candidate) >= 2:
                turns = calculate_turn(self.valid_cell_list[candidate[-2]], self.valid_cell_list[candidate[-1]], self.valid_cell_list[cell_idx])
            else:
                turns = 0
            extra_energy = self.turn_weight*turns+self.distance_weight*distance
            #print("extra_energy: ", extra_energy)
            if extra_energy < energy_available:
                candidate.append(cell_idx)
                candidate = self.add_node_end(candidate, energy_available-extra_energy)
                return candidate
        return candidate
    
    def check_if_valid_path(self, candidate):
        for step in range(len(candidate)-1):
            if candidate[step+1] not in self.adj_dict[candidate[step]]:
                print("Problem at step ", step)
                print(candidate[step-2:step+3])
                return False
        return True
        
        
        for path in candidate:
            for step in range(len(path)-1):
                if path[step+1] not in self.adj_dict[path[step]]:
                    print("Problem at step ", step)
                    print(candidate)
                    return False
        return True
    def remove_path_crossing(self, candidate, case):
        uav1 = random.randint(0,self.number_uavs-1)
        if case == 0:
            uav2 = random.randint(0,self.number_uavs-1)
        elif case == 1:
            uav2 = uav1
        elif case == 2:
            aux_list = list(range(0,self.number_uavs))
            aux_list.remove(uav1)
            uav2 = random.choice(aux_list)
        step_list = list(range(len(candidate[uav1])-1))
        #random.shuffle(step_list)
        for step in step_list:
            i1 = self.valid_cell_list[candidate[uav1][step]].i
            j1 = self.valid_cell_list[candidate[uav1][step]].j
            i2 = self.valid_cell_list[candidate[uav1][step+1]].i
            j2 = self.valid_cell_list[candidate[uav1][step+1]].j
            if abs(i1-i2)+abs(j1-j2) == 2: #step is diagonal
                for aux in range(len(candidate[uav2])-1):
                    i3 = self.valid_cell_list[candidate[uav2][aux]].i
                    j3 = self.valid_cell_list[candidate[uav2][aux]].j
                    i4 = self.valid_cell_list[candidate[uav2][aux+1]].i
                    j4 = self.valid_cell_list[candidate[uav2][aux+1]].j
                    if i1+i2 == i3+i4 and j1+j2 == j3+j4 and not (i1==i3 and j1==j3) and not (i1==i4 and j1==j4):
                        #print("Cross detected")
                        #The paths cross
                        if uav1 == uav2:
                            #Modifications within a single path
                            if step < aux:
                                aux_list = candidate[uav1][step+1:aux+1]
                                aux_list.reverse()
                                candidate[uav1][step+1:aux+1] = aux_list
                            else:
                                aux_list = candidate[uav1][aux+1:step+1]
                                aux_list.reverse()
                                candidate[uav1][aux+1:step+1] = aux_list
                        else:
                            #Modifications in different paths
                            aux_list1 = copy.deepcopy(candidate[uav1][:step+1] + candidate[uav2][aux+1:])
                            #if not self.check_if_valid_path(aux_list1):
                            #    print(candidate[uav1][:step+2])
                            #    print(candidate[uav2][aux:])
                            #    exit()
                            aux_list2 = copy.deepcopy(candidate[uav2][:aux+1] + candidate[uav1][step+1:])
                            #if not self.check_if_valid_path(aux_list2):
                            #    print(candidate[uav2][:aux+2])
                            #    print(candidate[uav1][step:])
                            #    exit()
                            aux_list1 = self.adjust_path_batt(aux_list1, uav1)
                            aux_list2 = self.adjust_path_batt(aux_list2, uav2)
                            candidate[uav1]= aux_list1
                            candidate[uav2]= aux_list2
                        return candidate
        return candidate
        
    def split_in_common_cell(self, candidate):
        uav1 = random.randint(0,self.number_uavs-1)
        uav2 = random.randint(0,self.number_uavs-1)
        step_list = list(range(len(candidate[uav1])-1))
        #random.shuffle(step_list)
        for step in step_list:
            for aux in range(len(candidate[uav2])-1):
                if candidate[uav1][step] == candidate[uav2][aux]: #the cell is visited twice
                    if uav1 == uav2 and step != aux: #The cell is revisited by the same path
                        #print("Cross detected")
                        if step < aux:
                            aux_list = candidate[uav1][step+1:aux]
                            aux_list.reverse()
                            candidate[uav1][step+1:aux] = aux_list
                        else:
                            aux_list = candidate[uav1][aux+1:step]
                            aux_list.reverse()
                            candidate[uav1][aux+1:step] = aux_list
                        return candidate
                    elif uav1 != uav2:
                        #Modifications in different paths
                        aux_list1 = copy.deepcopy(candidate[uav1][:step+1] + candidate[uav2][aux+1:])
                        #if not self.check_if_valid_path(aux_list1):
                        #    print(candidate[uav1][:step+2])
                        #    print(candidate[uav2][aux:])
                        #    exit()
                        aux_list2 = copy.deepcopy(candidate[uav2][:aux+1] + candidate[uav1][step+1:])
                        #if not self.check_if_valid_path(aux_list2):
                        #    print(candidate[uav2][:aux+2])
                        #    print(candidate[uav1][step:])
                        #    exit()
                        aux_list1 = self.adjust_path_batt(aux_list1, uav1)
                        aux_list2 = self.adjust_path_batt(aux_list2, uav2)
                        candidate[uav1]= aux_list1
                        candidate[uav2]= aux_list2
                        return candidate
        return candidate
    
    def adjust_path_batt(self, candidate, uav):
        path = [self.valid_cell_list[idx] for idx in candidate]
        step_distance = 0
        step_turns = 0
        energy_consumed = 0
        for idx in range(len(path)-1):
            step_distance = math.sqrt((path[idx+1].x - path[idx].x)**2 + (path[idx+1].y - path[idx].y)**2)
            if idx != 0:
                step_turns = calculate_turn(path[idx-1], path[idx], path[idx+1]) #in degrees
            energy_consumed = energy_consumed + self.turn_weight*step_turns + self.distance_weight*step_distance
            #If the there is no more energy available, take out the rest of the path
            if energy_consumed > self.initial_energies[uav]:
                return candidate[0:idx]
        #If we get to this point, we still have enough energy for another step
        candidate = self.add_node_end(candidate, self.initial_energies[uav]-energy_consumed)
        return candidate
    
    def calculate_candidate_battery_use(self, candidate):
        path = [self.valid_cell_list[idx] for idx in candidate]
        step_distance = 0
        step_turns = 0
        energy_consumed = 0
        for idx in range(len(path)-1):
            step_distance = math.sqrt((path[idx+1].x - path[idx].x)**2 + (path[idx+1].y - path[idx].y)**2)
            if idx != 0:
                step_turns = calculate_turn(path[idx-1], path[idx], path[idx+1]) #in degrees
            energy_consumed = energy_consumed + self.turn_weight*step_turns + self.distance_weight*step_distance
        return energy_consumed
    
    def get_indexes(self, paths):
        paths_idx = []
        for path in paths:
            path_idx = []
            for cell in path:
                idx, aux = search_for_cell_ij(self.valid_cell_list, cell.i,cell.j)
                path_idx.append(idx)
            paths_idx.append(path_idx)
        return paths_idx
    
    def get_random_neighbour(self, accepted_path):
        candidate = copy.deepcopy(accepted_path)
        case = random.choice(self.neighbour_cases)
        uav = random.randint(0,self.number_uavs-1)
        if case == 1:
            #Remove a node form the middle of the path
            candidate[uav] = self.remove_node_mid(candidate[uav])
            #Check if new path doesnt excede the UAV battery constraint
            candidate[uav] = self.adjust_path_batt(candidate[uav], uav)
        elif case == 2:
            #Change the position of a node in the middle of the path
            candidate[uav] = self.change_node_position(candidate[uav])
            #Check if new path doesnt excede the UAV battery constraint
            candidate[uav] = self.adjust_path_batt(candidate[uav], uav)
        elif case == 3:
            #Add a node in the middle of the path
            candidate[uav] = self.add_node_mid(candidate[uav])
            #Check if new path doesnt excede the UAV battery constraint
            candidate[uav] = self.adjust_path_batt(candidate[uav], uav)
        elif case == 4:
            #If a cross with no common cell is detected, change the path terminations
            candidate = self.remove_path_crossing(candidate, 0) #battery adjustment done inside
        #elif case == 6:
        #    candidate = self.remove_path_crossing(candidate, 2)
        elif case == 5:
            #Change the starting position of a path
            candidate = self.change_initial_position(candidate, uav)
            
            #If the paths visit the same cell, change the path terminations
            #candidate = self.split_in_common_cell(candidate)
            
        #In the case 1 it happens a lot that the node to be removed is the last and the candidate is the same as the path
        if (case == 1 or case == 4 or case == 5) and candidate == accepted_path:
            case = random.randint(2,3)
            if case == 2:
                #Change the position of a node in the middle of the path
                candidate[uav] = self.change_node_position(candidate[uav])
                candidate[uav] = self.adjust_path_batt(candidate[uav], uav)
            elif case == 3:
                #Add a node in the middle of the path
                candidate[uav] = self.add_node_mid(candidate[uav])
                candidate[uav] = self.adjust_path_batt(candidate[uav], uav)
        
        return candidate
    
    def calculate_f_inf(self):
        f_inf = 0
        energy_list = []
        for i in range(1000):
            random.seed(i)
            path = self.random_walk_initial_guess()
            energy_list.append(self.calculate_energy(self.get_indexes(path)))
        random.seed(time.time())
        f_inf = sum(energy_list)/len(energy_list)
        return f_inf
    
    def thread_is_behind(self, curr_thread_idx):
        if all([self.thread_iteration[curr_thread_idx] <= thread_iter for thread_iter in self.thread_iteration[0:self.number_threads]]):
            return True
        else:
            return False
        """
        #print("L_k = "+str(self.L_k)+str(self.thread_iteration[0:self.number_threads]))
        first = self.thread_iteration[0]
        for n_loops in self.thread_iteration[0:self.number_threads]:
            if first != n_loops:
                #print("Thread waiting")
                return False
        #print("Thread running")
        return True
        """
    def all_threads_synched(self, curr_thread_idx):
        if all([self.thread_last_update_iteration[curr_thread_idx] == last_update_iter for last_update_iter in self.thread_last_update_iteration[0:self.number_threads]]):
            return True
        else:
            return False
        
        if all([self.threads_paths_energy[curr_thread_idx] == self.threads_paths_energy[thread_idx] for thread_idx in range(self.number_threads) if self.thread_iteration[curr_thread_idx] > self.thread_iteration[thread_idx]]):
            return True
        else:
            return False
    
    def all_threads_at_same_iter(self, curr_thread_idx):
        if all([self.thread_iteration[curr_thread_idx] == thread_iter for thread_iter in self.thread_iteration[0:self.number_threads]]):
            return True
        else:
            return False
    
    def run_SA_in_thread(self, thread_idx, threads_path, threads_finished_loop_cond):
        thread_start_time = time.time()
        thread_start_process_time = time.process_time()
        #Get idx in path
        accepted_path = self.get_indexes(self.initial_guess_list[thread_idx])
        energy = self.calculate_energy(accepted_path)
        #print("Initial energy: ", energy)
        #self.initial_temp = self.calculate_initial_temperature(accepted_path)
        c_k = self.initial_temp
        c_k_prev = 0
        f_k = 0
        f_k_prev = 0
        #f_inf = self.calculate_f_inf()
        #print("f_inf = ", f_inf)
        #print("Initial path energy: ", energy)
        
        iterations = 0
        energy_list = []
        energy_list.append(energy)
        #term_cond = 100
        #e_s = self.stop_criteria
        while c_k > self.final_temp: #Termination condition
        #while iterations == 0 or abs((f_k-f_k_prev)/(c_k-c_k_prev)/f_inf*c_k) >= e_s:
            
            candidate_path_energy = []
            for i in range(self.L_k):
                #randomly choose a modification to perform on the path
                candidate = self.get_random_neighbour(accepted_path)
                #Calculate the energy of this new path
                energy_new = self.calculate_energy(candidate)
                candidate_path_energy.append(energy_new)
                if energy_new < energy or random.random() < self.prob_accept(energy - energy_new, c_k):
                    energy = energy_new
                    accepted_path = copy.deepcopy(candidate)
            #std_dev = np.std(candidate_path_energy)
            #f_k_prev = f_k
            #f_k = sum(candidate_path_energy)/len(candidate_path_energy)
            #if c_k == self.initial_temp:
            #    f_inf = f_k
            #    print("f_inf = ", f_inf)
            
            #c_k_prev = c_k
            c_k = c_k * self.cooling_factor
            
            #std_dev = np.std(candidate_path_energy)
            #alpha = math.log(1+self.delta)/(3*std_dev)
            #c_k = c_k/(1+alpha*c_k)
            #print(c_k)
            #print(c_k/c_k_prev)
            #print("Temperature = ", c_k_prev, "Term_cond = ", abs((f_k-f_k_prev)/(c_k-c_k_prev)/f_inf*c_k), "alpha: ", c_k/c_k_prev)
            #print("Temperature = ", c_k_prev)
            energy_list.append(energy)
            iterations += 1
            if self.synchronism == 1:
                #Acquires the lock
                with self.threads_finished_loop_cond:
                    #If the thread is ahead of schedule, wait, otherwise move on
                    while not self.thread_is_behind(thread_idx):
                        self.threads_finished_loop_cond.wait()
                    #Changes the iterations array
                    self.thread_iteration[thread_idx] = iterations
                    #print("Thread "+str(thread_idx)+" updated iteration. Current status: " + str(self.thread_iteration[0:self.number_threads]))
                    self.threads_finished_loop_cond.notify_all()
                    while not self.all_threads_synched(thread_idx):
                        self.threads_finished_loop_cond.wait()
                    #Changes its current accepted path
                    threads_path[:] = accepted_path
                    #Updates its current accepted path energy
                    self.threads_paths_energy[thread_idx] = energy
                    #Notify any remaining waiting threads
                    self.threads_finished_loop_cond.notify_all()
                    #print("Thread "+str(thread_idx)+" updated path energy. Current status: " + str(self.thread_iteration[0:self.number_threads]))
                    #Wait for all threads to complete the iteration before comparing results
                    while not self.all_threads_at_same_iter(thread_idx):
                        self.threads_finished_loop_cond.wait()
                    #Find the best path and copy it and its energy
                    min_energy = min(self.threads_paths_energy[0:self.number_threads])
                    min_energy_thread_idx = list(self.threads_paths_energy[0:self.number_threads]).index(min_energy)
                    threads_path[:] = self.threads_paths[min_energy_thread_idx]
                    
                    self.thread_last_update_iteration[thread_idx] = iterations
                    
                    self.threads_paths_energy[thread_idx] = min_energy
                    self.threads_finished_loop_cond.notify_all()
                    #print("Thread "+str(thread_idx)+" updated best path. Current status: " + str(self.thread_iteration[0:self.number_threads]))
                    
        if self.synchronism == 0:
            threads_path[:] = accepted_path
            self.threads_paths_energy[thread_idx] = energy
        #plt.figure()
        #plt.title("Energy evolution through iterations")
        #plt.plot(energy_list)
        #plt.show()
        thread_end_process_time = time.process_time()
        thread_end_time = time.time()
        self.threads_process_time[thread_idx] = thread_end_process_time-thread_start_process_time
        self.threads_time[thread_idx] = thread_end_time-thread_start_time
        
    
    def generate_uav_path(self, save_fig, fig_name):
        #self.threads_paths_energy = multiprocessing.Array('f', [0 for i in range(self.number_threads)])
        #self.threads_process_time = multiprocessing.Array('f', [0 for i in range(self.number_threads)])
        #self.threads_time = multiprocessing.Array('f', [0 for i in range(self.number_threads)])
        #self.thread_iteration = multiprocessing.Array('i', [0 for i in range(self.number_threads)])
        #self.thread_last_update_iteration = multiprocessing.Array('i', [0 for i in range(self.number_threads)])
        
        my_lock = multiprocessing.Lock()
        threads_finished_loop_cond = multiprocessing.Condition(lock=my_lock)
        thread_idx = 0
        thread_list = []
        #Run the SA algorithm in the specified number of threads
        for thread_idx in range(self.number_threads):
            aux_thread = multiprocessing.Process(target=self.run_SA_in_thread, args=(thread_idx, self.threads_paths[thread_idx],threads_finished_loop_cond,))
            #aux_thread.daemon = True
            aux_thread.start()
            thread_list.append(aux_thread)
        
        #Wait for the threads to finish
        for aux_thread in thread_list:
            aux_thread.join()
            #pid, exit_status, resource_usage = os.wait4(aux_thread.pid, 0)
            #user_time += resource_usage.ru_utime
            #system_time += resource_usage.ru_stime

        #print("Paths energies: ", list(self.threads_paths_energy))
        #Ge the result from the thread that produced the best path
        best_path_energy = min(self.threads_paths_energy)
        for i in range(self.number_threads):
            if self.threads_paths_energy[i] == best_path_energy:
                #print("Best path: ", i)
                #print("Energy of best path: ", best_path_energy)
                #print(self.threads_paths[i])
                break
        #best_thread_indx = self.threads_paths_energy.index(best_path_energy)
        accepted_path = self.threads_paths[i]
        if save_fig==1:
            f = open('./tese/code_var_poc/result_images/' + fig_name+'.txt', "a")
            f.write("Using simulated annealing v2\n")
            if self.type_init == 0:
                f.write("Initialized with Attraction algorithm\n")
            elif self.type_init == 1:
                f.write("Initialized with Random walk\n")
            f.write("Initial temp: " + str(self.initial_temp) + '\n')
            f.write("L_k: " + str(self.L_k) + '\n')
            f.write("Final temp: " + str(self.final_temp) + '\n')
            f.write("cooling factor: " + str(self.cooling_factor) + '\n')
            f.write("Number of UAVs: " + str(self.number_uavs) + '\n')
            f.write("Energies available: " + str(self.initial_energies) + '\n')
            f.write("Initial positions: " + str(self.initial_positions) + '\n')
            f.write("Number of threads: " + str(self.number_threads) + " Synchronism: "+ str(self.synchronism) + '\n')
            f.write("Threads path energy results: " + str(list(self.threads_paths_energy[0:self.number_threads])) + '\n')
            f.write("Accepted path energy: " + str(best_path_energy) + '\n')
            f.write("Path accepted: " + str(accepted_path) + '\n')
            f.write("Max thread processing time: " + str(max(self.threads_process_time)) + '\n')
            f.write("Sum of threads processing time: " + str(sum(self.threads_process_time)) + '\n')
            f.write("Max thread wall-clock time: " + str(max(self.threads_time)) + '\n')
            f.write("Sum of threads wall-clock time: " + str(sum(self.threads_time)) + '\n')
            f.close()
        #print("Accepted path energy: ", energy)
        #min_energy = min(candidate_path_energy)
        #print("Minimum candidate path energy: ", min_energy)
        self.paths_idx = copy.deepcopy(accepted_path)
        self.paths = [[self.valid_cell_list[idx] for idx in aux_path] for aux_path in accepted_path]
        #self.path = [self.valid_cell_list[idx] for idx in candidate_path_list[candidate_path_energy.index(min_energy)]]

     
class AntColonyOpt_v2():
    def __init__(self, cell_list, d, initial_energies, number_uavs, pod):
        
        #self.number_workers = number_workers
        self.number_uavs = number_uavs
        self.valid_cell_list = [cell for cell in cell_list if cell.status == 1]
        self.max_poc = max(cell.poc for cell in self.valid_cell_list)
        self.min_poc = min(cell.poc for cell in self.valid_cell_list)
        self.sum_poc = sum(cell.poc for cell in self.valid_cell_list)
        self.n_valid_cells = len(self.valid_cell_list)
        self.d = d
        self.initial_energies = initial_energies
        #if number_workers <= 0:
        #    print("The number of workers must be a positive integer")
        #   exit()

        self.adj_dict = {idx:[] for idx in range(len(self.valid_cell_list))}
        self.create_adjacency_dict()
        
        self.curr_iter = 0
        self.pod = pod
        self.factor = 0.01
        self.turn_weight = 0.0173
        self.distance_weight = 0.1164
        self.d = d
        self.max_energy = self.distance_weight * self.d * math.sqrt(2) + 180*self.turn_weight

        self.max_iterations = 100
        self.alpha = 0.9
        self.beta = 1.5
        self.evaporation = 0.01
        self.Q = 0.015
        
        self.number_of_nodes = 0
        
        self.min_heuristic = min(cell.poc for cell in self.valid_cell_list)/10
        
        self.root_node = None
        
        #print(self.min_poc)

    def create_adjacency_dict(self):
        """Fills in a dictionary with keys as cells indexes and values as a list of indexes of adjacent cells"""
        #Using 8 connected definition
        for idx1 in range(len(self.valid_cell_list)):
            for idx2 in range(idx1+1, len(self.valid_cell_list)):
                if check_if_cells_adjacent_8_conn(self.valid_cell_list[idx1], self.valid_cell_list[idx2]):
                    self.adj_dict[idx1].append(idx2)
                    self.adj_dict[idx2].append(idx1)
        #Create the dictionary entre for the first virtual node
        self.adj_dict[-1] = [idx for idx in range(len(self.valid_cell_list))]

    def get_final_path_performance(self):
        paths_idx = self.get_final_path()
        return calculate_objective_multi(self.valid_cell_list, paths_idx, self.pod, self.factor)

    def get_final_path(self):
        #Generate a full path starting at the root following the path of most pheromones
        current_node = self.root_node
        paths_idx = [[] for _ in range(self.number_uavs)]
        while(self.is_not_terminal(current_node)):
            max_child = max(current_node.children, key=lambda x: x.pheromones)
            #max_child = self.choose_child(current_node)
            paths_idx[max_child.last_uav_idx].append(max_child.cells_idx[max_child.last_uav_idx])
            current_node = max_child
        
        return paths_idx
    
    def run_single_ACO(self, save_fig=0, fig_name=''):
        initial_cells = [-1 for _ in range(self.number_uavs)]
        self.root_node = ACO_Node(initial_cells, self.initial_energies, self.number_uavs-1, 0, self.evaporation)

        self.curr_iter = 0
        while self.curr_iter < self.max_iterations:
            #Generate a full path starting at the root
            current_node = self.root_node
                        
            while(self.is_not_terminal(current_node)):
                if len(current_node.children) == 0:
                    #The node is not terminal but hasnt been expanded yet
                    self.expand_node(current_node)
                
                #Choose one of the children as the next node
                current_node = self.choose_child(current_node)
            
            #The pheromone evaporation is done passively every time a node is checked out
            
            #Deposit the pheromones from the last path
            self.deposit_pheromones_from_last_node(current_node)
            
            #if self.curr_iter%1000 == 0:
            #    print(self.curr_iter)
                
            self.curr_iter += 1
        
        self.paths_idx = self.get_final_path()
        self.paths = [[self.valid_cell_list[cell_idx] for cell_idx in path] for path in self.paths_idx]
        
        if save_fig==1:
            f = open('./tese/code_var_poc/result_images/' + fig_name+'.txt', "a")
            f.write("Using AntColonyOpt_v2 algorithm\n")
            f.write("Paths: " + str(self.paths_idx) + '\n')
            f.write("Total number of nodes explored: " + str(self.number_of_nodes) + '\n')
            f.write("Q*max_iter = " + str(self.Q*self.max_iterations) + "\n")
            f.write("Q = " + str(self.Q) + "\n")
            f.write("max_iter = " + str(self.max_iterations) + "\n")
            f.write("alpha = " + str(self.alpha) + "\n")
            f.write("beta = " + str(self.beta) + "\n")
            f.write("evaporation = " + str(self.evaporation) + "\n")
            f.close()
        
        return self.paths
        
    def is_not_terminal(self, node):
        if len(node.children) != 0:
            return True
        #A terminal node is also reached if all the cells have been visited
        visited_list = []
        aux_node = node
        while(aux_node is not None):
            for uav in range(self.number_uavs):
                if aux_node.cells_idx[uav] not in visited_list and aux_node.cells_idx[uav] != -1:
                    visited_list.append(aux_node.cells_idx[uav])
            aux_node = aux_node.parent
        
        if len(visited_list)==len(self.valid_cell_list):
            return False
        
        if any(energy_rem > self.max_energy for energy_rem in node.uavs_energy_rem):
            return True
        
        #A terminal node is reached if none of the UAVs have energy left for more moves
        for uav in range(self.number_uavs):
            current_cell = node.cells_idx[uav]
            prev_cell = self.get_prev_cell(node, uav)
            for next_cell in self.adj_dict[current_cell]:
                if node.uavs_energy_rem[uav] > self.energy_necessary(prev_cell,current_cell,next_cell):
                    return True
        return False
    
    def expand_node(self, node):
        #Fully expands the current node
        current_node = node
        move_priority = list(range(current_node.last_uav_idx+1, self.number_uavs)) + list(range(0,current_node.last_uav_idx+1))
        
        for uav in move_priority:
            #Check if the expected next UAV has enough energy available and if yes, expand for that one
            possible_moves = self.possible_moves(current_node, uav)
            if len(possible_moves) > 0:
                break #uav is now one that can move
        
        for action in possible_moves: #check if all its possible moves have been performed
            
            positions = [pos if i != uav else action for i, pos in enumerate(current_node.cells_idx)]
            
            current_cell = current_node.cells_idx[uav]
            prev_cell = self.get_prev_cell(current_node, uav)
            next_cell = action
            energy_rem = copy.deepcopy(current_node.uavs_energy_rem)
            energy_rem[uav] = current_node.uavs_energy_rem[uav] - self.energy_necessary(prev_cell,current_cell,next_cell)
            
            new_node = ACO_Node(positions, energy_rem, uav, self.curr_iter, self.evaporation, current_node)
            #new_node.heuristic = self.calculate_heuristic(new_node)
            node.children.append(new_node)
            
            self.number_of_nodes += 1
    
        return node.children
    
    
    def possible_moves(self, node, uav):
        moves = []
        current_cell = node.cells_idx[uav]
        prev_cell = self.get_prev_cell(node, uav)
        for next_cell in self.adj_dict[current_cell]:
            if node.uavs_energy_rem[uav] > self.energy_necessary(prev_cell,current_cell,next_cell):
                moves.append(next_cell)
        return moves
    
    def get_prev_cell(self, node, uav):
        current_cell = node.cells_idx[uav]
        aux_node = node.parent
        while(aux_node is not None):
            if aux_node.cells_idx[uav] != current_cell:
                return aux_node.cells_idx[uav]
            aux_node = aux_node.parent
        return current_cell
    
    def energy_necessary(self, prev_cell, current_cell, next_cell):
        return self.distance_weight*self.calculate_distance(current_cell, next_cell) + self.turn_weight*self.calculate_turn(prev_cell,current_cell,next_cell)
    
    def calculate_distance(self, cell1_idx, cell2_idx):
        if cell1_idx == -1:
            return 0
        cell1 = self.valid_cell_list[cell1_idx]
        cell2 = self.valid_cell_list[cell2_idx]
        return math.sqrt((cell1.x-cell2.x)**2+(cell1.y-cell2.y)**2)

    def calculate_turn(self, cell1_idx, cell2_idx, cell3_idx):
        """Calculate the degrees involved in turing from cell1, 2 and 3"""
        if cell1_idx == -1 or cell2_idx == -1:
            return 0
        
        cell1 = self.valid_cell_list[cell1_idx]
        cell2 = self.valid_cell_list[cell2_idx]
        cell3 = self.valid_cell_list[cell3_idx]
        
        vec1 = np.array([cell2.x-cell1.x, cell2.y-cell1.y])
        vec2 = np.array([cell3.x-cell2.x, cell3.y-cell2.y])
        
        if (np.linalg.norm(vec1)*np.linalg.norm(vec2)) == 0:
            sys.exit('Cells are repeated in the path')
        else:
            cos_angle = np.dot(vec1, vec2)/(np.linalg.norm(vec1)*np.linalg.norm(vec2))
            cos_angle = round(cos_angle,4)
            angle = np.arccos(cos_angle)/np.pi*180
        return angle #in degrees
    
    def choose_child_new(self, node, deterministic = False):
        p_children = []
        for child in node.children:            
            pheromones = child.update_and_get_pheromones(self.curr_iter, self.evaporation)
            prob = pheromones**self.alpha * child.heuristic ** self.beta
            p_children.append(prob)
        
        sum_prob = sum(p_children)
        p_children = [p/sum_prob for p in p_children]
        
        if deterministic:
            max_value = max(p_children)
            max_child_idx = p_children.index(max_value)
            return node.children[max_child_idx]
            
        next_node = random.choices(node.children, weights=p_children)[0]
        return next_node
    
    def choose_child(self, node, deterministic = False):
        p_children = []
        for child in node.children:
            new_cell_idx = child.cells_idx[child.last_uav_idx]
            pos_cumulative = (1-self.pod)**child.n_times_visited_prev * self.pod * self.valid_cell_list[new_cell_idx].poc
            heuristic = self.min_heuristic + pos_cumulative        
            #heuristic = (self.min_poc*self.pod + pos_cumulative)/(self.max_poc*self.pod)
            
            #if child.visited_prev:
            #    heuristic = self.min_heuristic
            #else:
            #    new_cell_idx = child.cells_idx[child.last_uav_idx]
            #    heuristic = self.min_heuristic + self.valid_cell_list[new_cell_idx].poc
            
            pheromones = child.update_and_get_pheromones(self.curr_iter, self.evaporation)
            prob = pheromones**self.alpha * heuristic ** self.beta
            p_children.append(prob)
        
        sum_prob = sum(p_children)
        p_children = [p/sum_prob for p in p_children]
        
        if deterministic:
            max_value = max(p_children)
            max_child_idx = p_children.index(max_value)
            return node.children[max_child_idx]
            
        next_node = random.choices(node.children, weights=p_children)[0]
        return next_node
    
    def calculate_objective_func_from_last_node(self, last_node):
        paths_idx = [[] for _ in range(self.number_uavs)]
        #paths_idx[max_child.last_uav_idx].append(max_child.cells_idx[max_child.last_uav_idx])
        path = last_node.get_nodes_in_path()
        for node in path[1:]:
            paths_idx[node.last_uav_idx].append(node.cells_idx[node.last_uav_idx])
        
        objective = calculate_objective_multi(self.valid_cell_list, paths_idx, self.pod, self.factor)
        return objective
    
    def deposit_pheromones_from_last_node(self, last_node):
        objective_func = self.calculate_objective_func_from_last_node(last_node)
        aux_node = last_node
        while(aux_node is not None):
            #aux_node.pheromones += self.Q*objective_func
            aux_node.update_and_get_pheromones(self.curr_iter, self.evaporation, self.Q*objective_func)
            aux_node = aux_node.parent

    def get_next_cell_greedy_walk(self, cell_idx, visited_cells):
        #Finds the next cell to visit in the simulated path
        neighbours = self.adj_dict[cell_idx]
        bias_neighbours = [(1-self.pod)**visited_cells[i]*self.pod*self.valid_cell_list[i].poc for i in neighbours]
        if sum(bias_neighbours) == 0:
            next_cell_idx = random.choice(neighbours)
        else:
            max_bias_idx = bias_neighbours.index(max(bias_neighbours))
            next_cell_idx = neighbours[max_bias_idx]
        return next_cell_idx
    
    def simulate_path_from_last_node(self, node):
        paths_idx = self.get_paths_until_node(node)
        energies_rem = copy.deepcopy(node.uavs_energy_rem)
        stopped_uavs = [0 for i in range(self.number_uavs)]
        
        visited_cells = {i:0 for i in range(len(self.valid_cell_list))}
        for aux_path in paths_idx:
            for aux_cell in aux_path:
                visited_cells[aux_cell] += 1
        
        uav = node.last_uav_idx + 1
        while(1):
            if all(stopped_uavs):
                counter += 1
                if counter == self.number_uavs:
                    break
            else:
                counter = 0
            if uav == self.number_uavs:
                uav = 0
            
            if len(paths_idx[uav]) == 0:
                current_cell = -1
                prev_cell = -1
            elif len(paths_idx[uav]) == 1:
                current_cell = paths_idx[uav][-1]
                prev_cell = -1
            else:
                current_cell = paths_idx[uav][-1]
                prev_cell = paths_idx[uav][-2]
            
            next_cell = self.get_next_cell_greedy_walk(current_cell, visited_cells)
                        
            energy_necessary = self.energy_necessary(prev_cell, current_cell, next_cell)

            if energies_rem[uav] > energy_necessary:
                energies_rem[uav] -= energy_necessary
                paths_idx[uav].append(next_cell)
                visited_cells[next_cell] += 1
                stopped_uavs[uav] = 0
            else:
                stopped_uavs[uav] = 1

            uav += 1
        return paths_idx
    
    def get_paths_until_node(self, node):
        node_path = node.get_nodes_in_path()
        paths_idx = [[] for i in range(self.number_uavs)]
        
        if len(node_path) <= 1:
            return paths_idx
        
        for aux_node in node_path[1:]:
            last_moved_uav = aux_node.last_uav_idx
            last_moved_cell = aux_node.cells_idx[last_moved_uav]
            paths_idx[last_moved_uav].append(last_moved_cell)
        
        return paths_idx #Does not include -1

    def calculate_heuristic(self, node):
        
        #new_cell_idx = node.cells_idx[node.last_uav_idx]
        #pos_cumulative = (1-self.pod)**node.n_times_visited_prev * self.pod * self.valid_cell_list[new_cell_idx].poc
        #heuristic = self.min_heuristic + pos_cumulative
        
        #Simulate a case for the rest of the path
        paths_idx = self.simulate_path_from_last_node(node)
        #Calculate the objective function for these
        heuristic = calculate_objective_multi(self.valid_cell_list, paths_idx, self.pod, self.factor)
        return heuristic
    

class MonteCarloSearch():
    def __init__(self, cell_list, d, initial_energies, number_uavs, pod):
        self.number_uavs = number_uavs
        self.initial_guess_list = []
        self.valid_cell_list = [cell for cell in cell_list if cell.status == 1]
        self.paths = []
        self.paths_idx = []
        self.d = 0
        self.initial_energies = initial_energies
        self.adj_dict = {idx:[] for idx in range(len(self.valid_cell_list))}
        self.factor = 0.01
        self.turn_weight = 0.0173
        self.distance_weight = 0.1164
        self.min_energy = self.distance_weight * self.d
        self.number_of_nodes = 0
        self.number_of_iterations = 0
        self.pod = pod
        self.final_node_selection = 0 #0 - max child, 1 - robust child, 2 - secure child
        self.A = 4 #only used in the secure child case
        self.n_rollouts_per_sim = 1
        #self.c = math.sqrt(2)
        self.c = 0.01
        self.terminal_state_reached = 0
        
        self.create_adjacency_dict()
        
    def create_adjacency_dict(self):
        """Fills in a dictionary with keys as cells indexes and values as a list of indexes of adjacent cells"""
        #Using 8 connected definition
        for idx1 in range(len(self.valid_cell_list)):
            for idx2 in range(idx1+1, len(self.valid_cell_list)):
                if check_if_cells_adjacent_8_conn(self.valid_cell_list[idx1], self.valid_cell_list[idx2]):
                    self.adj_dict[idx1].append(idx2)
                    self.adj_dict[idx2].append(idx1)
        #Create the dictionary entre for the first virtual node
        self.adj_dict[-1] = [idx for idx in range(len(self.valid_cell_list))]
        #self.adj_dict[-1] = [2]
        
        
    def get_prev_cell(self, node, uav):
        current_cell = node.cells_idx[uav]
        aux_node = node.parent
        while(aux_node is not None):
            if aux_node.cells_idx[uav] != current_cell:
                return aux_node.cells_idx[uav]
            aux_node = aux_node.parent
        return current_cell
        
    def calculate_turn(self, cell1_idx, cell2_idx, cell3_idx):
        """Calculate the degrees involved in turing from cell1, 2 and 3"""
        if cell1_idx == -1 or cell2_idx == -1:
            return 0
        
        cell1 = self.valid_cell_list[cell1_idx]
        cell2 = self.valid_cell_list[cell2_idx]
        cell3 = self.valid_cell_list[cell3_idx]
        
        vec1 = np.array([cell2.x-cell1.x, cell2.y-cell1.y])
        vec2 = np.array([cell3.x-cell2.x, cell3.y-cell2.y])
        
        if (np.linalg.norm(vec1)*np.linalg.norm(vec2)) == 0:
            sys.exit('Cells are repeated in the path')
        else:
            cos_angle = np.dot(vec1, vec2)/(np.linalg.norm(vec1)*np.linalg.norm(vec2))
            cos_angle = round(cos_angle,4)
            angle = np.arccos(cos_angle)/np.pi*180
        return angle #in degrees
    
    def calculate_distance(self, cell1_idx, cell2_idx):
        if cell1_idx == -1:
            return 0
        cell1 = self.valid_cell_list[cell1_idx]
        cell2 = self.valid_cell_list[cell2_idx]
        return math.sqrt((cell1.x-cell2.x)**2+(cell1.y-cell2.y)**2)
    
    def energy_necessary(self, prev_cell, current_cell, next_cell):
        return self.distance_weight*self.calculate_distance(current_cell, next_cell) + self.turn_weight*self.calculate_turn(prev_cell,current_cell,next_cell)
        
    def is_not_terminal(self, node):
        
        """
        #A terminal node is also reached if all the cells have been visited
        visited_list = []
        aux_node = node
        while(aux_node is not None):
            for uav in range(self.number_uavs):
                if aux_node.cells_idx[uav] not in visited_list and aux_node.cells_idx[uav] != -1:
                    visited_list.append(aux_node.cells_idx[uav])
            aux_node = aux_node.parent
        
        if len(visited_list)==len(self.valid_cell_list):
            return False
        """
        
        #A terminal node is reached if none of the UAVs have energy left for more moves
        for uav in range(self.number_uavs):
            current_cell = node.cells_idx[uav]
            prev_cell = self.get_prev_cell(node, uav)
            for next_cell in self.adj_dict[current_cell]:
                if node.uavs_energy_rem[uav] > self.energy_necessary(prev_cell,current_cell,next_cell):
                    return True
        return False
    
    def possible_moves(self, node, uav):
        moves = []
        current_cell = node.cells_idx[uav]
        prev_cell = self.get_prev_cell(node, uav)
        for next_cell in self.adj_dict[current_cell]:
            if node.uavs_energy_rem[uav] > self.energy_necessary(prev_cell,current_cell,next_cell):
                moves.append(next_cell)
        return moves
        
    """def is_not_fully_expanded(self, node):
        #Returns true if there is still a child to the node that has not been generated yet
        move_priority = list(range(node.last_uav_idx+1, self.number_uavs)) + list(range(0,node.last_uav_idx+1))
        for uav in move_priority:
            #Check if the expected next UAV has enough energy available and if yes, expand for that one
            number_moves = len(self.possible_moves(node, uav))
            if number_moves > 0:
                if len(node.children) < number_moves:
                    return True
                else:
                    return False
        return False #only if none of the uavs can move"""
    
    """def expand(self, node):
        #From a not fully expanded node, find a new child
        move_priority = list(range(node.last_uav_idx+1, self.number_uavs)) + list(range(0,node.last_uav_idx+1))
        for uav in move_priority:
            #Check if the expected next UAV has enough energy available and if yes, expand for that one
            number_moves = len(self.possible_moves(node, uav))"""
    
    def best_child_UCT(self, node, C):
        max_child = node.children[0]
        max_value = max_child.Q/max_child.N + C*math.sqrt(2*math.log(node.N)/max_child.N)
        
        for child in node.children:
            value = child.Q/child.N + C*math.sqrt(2*math.log(node.N)/child.N)
            if max_value < value:
                max_value = value
                max_child = child
        
        return max_child
    
    def best_child_no_explored_check(self, node, C):
        max_child = node.children[0]
        max_value = max_child.Q_max + C*math.sqrt(2*math.log(node.N)/max_child.N)
        
        for child in node.children:
            value = child.Q_max + C*math.sqrt(2*math.log(node.N)/child.N)
            if max_value < value:
                max_value = value
                max_child = child
        
        return max_child
    
    def best_child(self, node, C):
        #not_fully_explored_list = node.children
        not_fully_explored_list = [aux_node for aux_node in node.children if aux_node.fully_explored == 0]
        
        max_child = not_fully_explored_list[0]
        max_value = max_child.Q_max + C*math.sqrt(2*math.log(node.N)/max_child.N)
        
        for child in not_fully_explored_list:
            value = child.Q_max + C*math.sqrt(2*math.log(node.N)/child.N)
            if max_value < value:
                max_value = value
                max_child = child
        
        return max_child

    def tree_policy(self, node):
        current_node = node
        while self.is_not_terminal(current_node):
            
            if current_node.fully_expanded == 0:
                move_priority = list(range(current_node.last_uav_idx+1, self.number_uavs)) + list(range(0,current_node.last_uav_idx+1))
                
                for uav in move_priority:
                    #Check if the expected next UAV has enough energy available and if yes, expand for that one
                    possible_moves = self.possible_moves(current_node, uav)
                    if len(possible_moves) > 0:
                        break #uav is now one that can move
            
            #if len(current_node.children) < len(possible_moves): #check if all its possible moves have been performed
                #Expand the node
                positions = copy.deepcopy(current_node.cells_idx)
                #Choose an action that will result in a child that hasnt been explored
                explored_actions = [aux_node.cells_idx[uav] for aux_node in current_node.children]
                for action in possible_moves:
                    if action not in explored_actions:
                        positions[uav] = action
                        break
                
                current_cell = current_node.cells_idx[uav]
                prev_cell = self.get_prev_cell(current_node, uav)
                next_cell = action
                energy_rem = copy.deepcopy(current_node.uavs_energy_rem)
                energy_rem[uav] = current_node.uavs_energy_rem[uav] - self.energy_necessary(prev_cell,current_cell,next_cell)
                
                new_node = MCS_Node(positions, energy_rem, uav, current_node)
                self.number_of_nodes += 1
                
                if not self.is_not_terminal(new_node): #If the expanded node is terminal, then all of its children have been explored
                    new_node.fully_explored = 1
                    new_node.fully_expanded = 1
                
                current_node.children.append(new_node)
                if len(current_node.children) == len(possible_moves):
                    current_node.fully_expanded = 1 #The current node is finally fully expanded after the last child was created
                
                return new_node
            else:
                #All the childs have been found, so get the next node
                current_node = self.best_child(current_node, self.c)
            
        return current_node
            
    """def tree_policy_slow(self, node):
        current_node = node
        while self.is_not_terminal(current_node):
            if self.is_not_fully_expanded(current_node):
                new_node = self.expand(current_node)
                return new_node
            else:
                current_node = self.best_child(current_node)"""
    
    def get_paths_until_node(self, node):
        node_path = node.get_nodes_in_path()
        paths_idx = [[] for i in range(self.number_uavs)]
        
        if len(node_path) <= 1:
            return paths_idx
        
        for aux_node in node_path[1:]:
            last_moved_uav = aux_node.last_uav_idx
            last_moved_cell = aux_node.cells_idx[last_moved_uav]
            paths_idx[last_moved_uav].append(last_moved_cell)
        
        return paths_idx #Does not include -1
        
    def get_next_cell_RW(self, cell_idx):
        #Finds the next cell to visit in the simulated path
        next_cell_idx = random.choice(self.adj_dict[cell_idx])
        return next_cell_idx

    def attraction(self, cell1_idx, cell2_idx, visited_cells):
        """Quantifies the attraction generated by cell2 on cell1"""
        #times_covered_prev = len([i for i in visited_cells if i==cell2_idx])
        
        if cell1_idx == -1:
            return (1-self.pod)**visited_cells[cell2_idx]*self.pod*self.valid_cell_list[cell2_idx].poc
        #elif cell2_idx == -1:
        #    return 0
        
        cell1 = self.valid_cell_list[cell1_idx]
        cell2 = self.valid_cell_list[cell2_idx]
        distance = math.sqrt((cell2.x - cell1.x)**2 + (cell2.y - cell1.y)**2)
        #attraction = cell2.poc*cell2.not_covered/math.exp(distance/self.d)
        
        #attraction = cell2.poc*cell2.not_covered/(distance/self.d)
        
        #not_covered = not cell2_idx in visited_cells
        #times_covered_prev = len([i for i in visited_cells if i==cell2_idx])
        pos_cummulative = (1-self.pod)**visited_cells[cell2_idx]*self.pod*cell2.poc
        
        #bad initial guess
        attraction = pos_cummulative*math.exp(-0.1*distance/self.d)
        return attraction
    
    def get_next_cell_att(self, cell_idx, visited_cells):
        #Finds the next cell to visit in the simulated path
        max_att = 0
        for cell2_idx in range(len(self.valid_cell_list)):
            if cell2_idx != cell_idx: #cell1.i != cell2.i or cell1.j != cell2.j:
                att = self.attraction(cell_idx, cell2_idx, visited_cells)
                if att> max_att:
                    max_att = att
                    max_idx = cell2_idx
        
        if cell_idx == -1:
            return max_idx
        
        # Performs graph search to find the best path to it
        traj_prob = TrajectoryProblem(self.valid_cell_list, self.valid_cell_list[cell_idx], self.valid_cell_list[max_idx])
        solution, path = traj_prob.solve()
        
        next_cell = path[1].state
        next_cell_idx, aux_cell = search_for_cell_ij(self.valid_cell_list, next_cell.i, next_cell.j)
        
        return next_cell_idx
    
    def get_next_cell_att_efficient(self, cell_idx, visited_cells, max_queue):
        #Finds the next cell to visit in the simulated path
        max_att = 0
        for cell2_idx in max_queue[0:10]:
            if cell2_idx != cell_idx: #cell1.i != cell2.i or cell1.j != cell2.j:
                att = self.attraction(cell_idx, cell2_idx, visited_cells)
                if att> max_att:
                    max_att = att
                    max_idx = cell2_idx
        
        if cell_idx == -1:
            return max_idx, max_queue
        
        # Performs graph search to find the best path to it
        traj_prob = TrajectoryProblem(self.valid_cell_list, self.valid_cell_list[cell_idx], self.valid_cell_list[max_idx])
        solution, path = traj_prob.solve()
        
        next_cell = path[1].state
        next_cell_idx, aux_cell = search_for_cell_ij(self.valid_cell_list, next_cell.i, next_cell.j)
        
        return next_cell_idx, max_queue
    
    def get_bias_toward_neighbour(self, cell2_idx, visited_cells):
        """Quantifies the attraction generated by cell2 on cell1"""
        times_covered_prev = len([i for i in visited_cells if i==cell2_idx])
        return (1-self.pod)**times_covered_prev*self.pod*self.valid_cell_list[cell2_idx].poc
    
    def get_next_cell_RW_biased(self, cell_idx, visited_cells):
        #Finds the next cell to visit in the simulated path
        neighbours = self.adj_dict[cell_idx]
        bias_neighbours = [(1-self.pod)**visited_cells[i]*self.pod*self.valid_cell_list[i].poc for i in neighbours]
        if sum(bias_neighbours) == 0:
            next_cell_idx = random.choice(neighbours)
        else:
            next_cell_idx = random.choices(neighbours, weights = bias_neighbours, k=1)[0]
        return next_cell_idx
    
    def get_next_cell_RW_hard_biased(self, cell_idx, visited_cells):
        #Finds the next cell to visit in the simulated path
        neighbours = self.adj_dict[cell_idx]
        bias_neighbours = [(1-self.pod)**visited_cells[i]*self.pod*self.valid_cell_list[i].poc for i in neighbours]
        if sum(bias_neighbours) == 0:
            next_cell_idx = random.choice(neighbours)
        else:
            max_bias_idx = bias_neighbours.index(max(bias_neighbours))
            next_cell_idx = neighbours[max_bias_idx]
        return next_cell_idx
    
    def simulate_path_from_last_node(self, node):
        paths_idx = self.get_paths_until_node(node)
        energies_rem = copy.deepcopy(node.uavs_energy_rem)
        stopped_uavs = [0 for i in range(self.number_uavs)]
        
        visited_cells = {i:0 for i in range(len(self.valid_cell_list))}
        for aux_path in paths_idx:
            for aux_cell in aux_path:
                visited_cells[aux_cell] += 1
        
        uav = node.last_uav_idx + 1
        while(1):
            if all(stopped_uavs):
                counter += 1
                if counter == self.number_uavs:
                    break
            else:
                counter = 0
            if uav == self.number_uavs:
                uav = 0
            
            if len(paths_idx[uav]) == 0:
                current_cell = -1
                prev_cell = -1
            elif len(paths_idx[uav]) == 1:
                current_cell = paths_idx[uav][-1]
                prev_cell = -1
            else:
                current_cell = paths_idx[uav][-1]
                prev_cell = paths_idx[uav][-2]
            
            
            #if len(visited_cells) == len(self.valid_cell_list): #all the cells have been visited
            #    break
            #else:
            
            #next_cell = self.get_next_cell_RW(current_cell)
            #next_cell = self.get_next_cell_att(current_cell, visited_cells)
            #next_cell = self.get_next_cell_RW_biased(current_cell, visited_cells)
            next_cell = self.get_next_cell_RW_hard_biased(current_cell, visited_cells)
            #next_cell, max_queue = self.get_next_cell_att_efficient(current_cell, visited_cells, max_queue)
            
            energy_necessary = self.energy_necessary(prev_cell, current_cell, next_cell)
            #turn = calculate_turn_from_actions(cell.prev_action, next_cell.prev_action)
            #distance = math.sqrt((next_cell.x - cell.x)**2 + (next_cell.y - cell.y)**2)
            #energy_necessary = self.turn_weight*turn + self.distance_weight*distance
            if energies_rem[uav] > energy_necessary:
                energies_rem[uav] -= energy_necessary
                paths_idx[uav].append(next_cell)
                visited_cells[next_cell] += 1
                stopped_uavs[uav] = 0
            else:
                stopped_uavs[uav] = 1
            #cell = copy.deepcopy(next_cell)
            #print("Current cell: ", cell.i, cell.j)
            uav += 1
        return paths_idx
    
    def default_policy_single_rollout(self, node):
        #Simulate a case for the rest of the path
        paths_idx = self.simulate_path_from_last_node(node)
        #Calculate the objective function for these
        reward = calculate_objective_multi(self.valid_cell_list, paths_idx, self.pod, self.factor)
        return reward
    
    def default_policy(self, node):
        rewards = []
        for _ in range(self.n_rollouts_per_sim):
            #Simulate a case for the rest of the path
            paths_idx = self.simulate_path_from_last_node(node)
            #Calculate the objective function for these
            reward = calculate_objective_multi(self.valid_cell_list, paths_idx, self.pod, self.factor)
            rewards.append(reward)
        avg_rewards = sum(rewards)/len(rewards)
        return avg_rewards
    
    def backup_reward(self, current_node, reward):
        aux_node = current_node
        while (aux_node is not None):
            aux_node.N = aux_node.N + 1
            aux_node.Q = aux_node.Q + reward
            
            if aux_node.Q_max < reward:
                aux_node.Q_max = reward
                if aux_node.Q_max_max < reward:
                    aux_node.Q_max_max = reward
            
            check_parent_fully_explored = aux_node.fully_explored #If the current node is fully explored, check if its parent is now fully explored
            
            aux_node = aux_node.parent
            
            if check_parent_fully_explored and (aux_node is not None):
                if aux_node.fully_expanded == 1:
                    aux_node.fully_explored = int(all(child.fully_explored for child in aux_node.children))
        
        #If the last node is fully explored, change the Q_max of the nodes in the path to eliminate the influence of the path that has already been fully explored
        aux_node = current_node.parent
        if (aux_node is not None) and aux_node.fully_explored:
            aux_node = aux_node.parent
            while (aux_node is not None):
                not_fully_explored_children = [child for child in aux_node.children if child.fully_explored == 0]
                if len(not_fully_explored_children) != 0:
                    aux_node.Q_max = max(child.Q_max for child in not_fully_explored_children)
                aux_node = aux_node.parent
        
            
        
    def calculate_eff_branching_factor(self):
        d = self.sol_depth
        N = self.number_of_nodes
        func = lambda B: ((B)**(d+1) - 1) / (B - 1) - N+1
        
        initial_guess = N**(1/d)
        
        eff_branching_factor = fsolve(func, initial_guess)
        return eff_branching_factor
    
    def max_child(self, node):
        max_child = node.children[0]
        max_value = max_child.Q_max_max
        
        for child in node.children:
            value = child.Q_max_max
            if max_value < value:
                max_value = value
                max_child = child
        
        return max_child
        
    def robust_child(self, node):
        n_visits_list = [child.N for child in node.children]
        max_visits_idx = n_visits_list.index(max(n_visits_list))
        aux_node = node.children[max_visits_idx]
        return aux_node

    def secure_child(self, node):
        max_child = node.children[0]
        max_value = max_child.Q + self.A/math.sqrt(max_child.N)
        
        for child in node.children:
            value = child.Q + self.A/math.sqrt(child.N)
            if max_value < value:
                max_value = value
                max_child = child
        
        return max_child
        
    
    def generate_path(self, time_limit, save_fig=0, fig_name=''):
        initial_cells = [-1 for i in range(self.number_uavs)]
        #Create the root node - all the UAVs are in a virtual cell that can access anywhere in the space
        root_node = MCS_Node(initial_cells, self.initial_energies, self.number_uavs-1)
        initial_time = time.process_time()
        self.number_of_nodes = 1
        self.number_of_iterations = 0
        while time.process_time() - initial_time < time_limit:
            if root_node.fully_explored == 1: #The tree has been fully explored - stop the iterations
                print("Tree fully explored!!")
                break
            current_node = self.tree_policy(root_node)
            reward = self.default_policy(current_node)
            self.backup_reward(current_node, reward)
            self.number_of_iterations += 1
            #print(len(root_node.children))
            
        self.sol_depth = 0
        aux_node = root_node
        while len(aux_node.children) != 0:
            if self.final_node_selection == 0:
                aux_node = self.max_child(aux_node)
            elif self.final_node_selection == 1:
                aux_node = self.robust_child(aux_node)
            elif self.final_node_selection == 2:
                aux_node = self.secure_child(aux_node)
            #aux_node.print()
            #print(aux_node.cells_idx, aux_node.fully_expanded, aux_node.fully_explored)
            self.sol_depth += 1
        
        
        #Check if a terminal state was reached, and if not perform a rollout from it and output the result
        self.terminal_state_reached = not self.is_not_terminal(aux_node)
        if self.terminal_state_reached:
            self.paths_idx = self.get_paths_until_node(aux_node)
        else:
            self.paths_idx =  self.simulate_path_from_last_node(aux_node) #Perform a rollout from the last node
        
        #self.paths_idx = self.get_paths_until_node(aux_node)
        self.paths = [[self.valid_cell_list[cell_idx] for cell_idx in path] for path in self.paths_idx]
        #print(self.paths_idx)
        #print("Total number of nodes explored: ", self.number_of_nodes)
        #print("Total number of iterations: ", self.number_of_iterations)
        #print("Effective branching factor: ", self.calculate_eff_branching_factor())
        #print("Terminal state reached: ", terminal_state_reached)
        if save_fig==1:
            f = open('./tese/code_var_poc/result_images/' + fig_name+'.txt', "a")
            f.write("Using MCS algorithm with greedy tree policy Q_max not repeating nodes changing Q_max\n")
            f.write("c: " + str(self.c) + '\n')
            f.write("terminal state reached: " + str(self.terminal_state_reached) + '\n')
            f.write("number of rollouts per sim: " + str(self.n_rollouts_per_sim) + '\n')
            f.write("Paths: " + str(self.paths_idx) + '\n')
            f.write("Total number of iterations: " + str(self.number_of_iterations) + '\n')
            f.write("Total number of nodes explored: " + str(self.number_of_nodes) + '\n')
            f.write("Effective branching factor: " + str(self.calculate_eff_branching_factor()) + "\n")
            f.close()
