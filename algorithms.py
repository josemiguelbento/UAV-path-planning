from utils import *
import math
import random
import time
from scipy.optimize import fsolve
import copy
import numpy as np
import multiprocessing

class Attraction_algorithm():
    """Class that describes the functions necessary for the implementation of the Attraction algorithm."""
    def __init__ (self, cell_list, d, initial_energies, number_uavs, pod):
        self.valid_cell_list = [cell for cell in copy.deepcopy(cell_list) if cell.status == 1]
        self.number_uavs = number_uavs
        self.paths = [[] for i in range(number_uavs)]
        self.paths_idx = [[] for i in range(number_uavs)]
        self.initial_energies = initial_energies
        self.turn_weight = 0.0173 #Energy required to perform one degree of a turn
        self.distance_weight = 0.1164 #Energy required for to move one meter
        self.d = d
        self.pod = pod
        
    def attraction(self, cell1, cell2):
        """Calculates the attraction generated by cell2 on a UAV placed on cell1."""
        distance = math.sqrt((cell2.x - cell1.x)**2 + (cell2.y - cell1.y)**2)
        pos_cummulative = (1-self.pod)**cell2.times_covered_prev*self.pod*cell2.poc
        attraction = pos_cummulative*math.exp(-0.1*distance/self.d)
        return attraction
    
    def calc_movement_dir(self, cell1):
        """Outputs the direction in which the UAV should move, expressed as [di, dj], where di and dj are the shifts in the grid indexes of the next cell relative to the current cell."""
        
        #Finds the cell in the AOI that produces the biggest attraction
        max_att = 0
        for idx, cell2 in enumerate(self.valid_cell_list):
            if cell1.i != cell2.i or cell1.j != cell2.j:
                att = self.attraction(cell1,cell2)
                if att> max_att:
                    max_att = att
                    max_cell = cell2
        
        if max_att == 0:
            #If all of the valid cells have been fully searched (only happens if POD = 100%), the max attraction is 0
            return 0
        
        #Use the A* algorithm to find a path from the current UAV position to the cell that produces the largest attraction
        traj_prob = TrajectoryProblem(self.valid_cell_list, cell1, max_cell)
        solution, path = traj_prob.solve()
        #Return the first step in the resulting path
        return solution[0]
    
    def get_next_cell(self, cell):
        """Returns the cell to which the UAV should move next."""
        solution = self.calc_movement_dir(cell) #Get the direction to which the UAV should move expressed as a shift in grid indexes
        if solution == 0:
            #All of the valid cells have been fully searched (only happens if POD = 100%), so no further search is required.
            return None, None
        idx, next_cell = search_for_cell_ij(self.valid_cell_list, cell.i+solution[1],cell.j+solution[2])
        next_cell.prev_action = solution
        return idx, next_cell
    
    def generate_uav_path(self):
        """Generates the paths of available UAVs using the Attraction algorithm."""
        stopped_uavs = [] #List with the stopped - 1/moving - 0 status of the UAVs
        
        #Randomly chooses a starting position for the paths of the available UAVs and initializes their paths
        dep_choices_idx = list(range(len(self.valid_cell_list)))
        for uav in range(self.number_uavs):
            #Bias the starting positions towards cells with a high POC value
            idx = random.choices(dep_choices_idx, weights = [self.valid_cell_list[i].poc for i in dep_choices_idx])[0]
            initial_cell = self.valid_cell_list[idx]
            cell = copy.deepcopy(initial_cell)
            cell.prev_action = ('FIRST', 0, 0)
            self.paths[uav].append(copy.deepcopy(cell))
            self.valid_cell_list[idx].times_covered_prev += 1
            self.paths_idx[uav].append(idx)
            stopped_uavs.append(0)
        energies_rem = copy.deepcopy(self.initial_energies)
        
        #Select the first UAV to start moving and run in a loop until they all run out of energy
        uav = 0
        while(1):
            
            #Stop the algorithm if all of the UAVs were given a chance to move, and none were able to
            if all(stopped_uavs):
                counter += 1
                if counter == self.number_uavs:
                    break
            else:
                counter = 0
            
            #Loop around the movement priority to the first UAV that moved
            if uav == self.number_uavs:
                uav = 0
            
            cell = self.paths[uav][-1] #Current position of the UAV
            idx, next_cell = self.get_next_cell(cell) #Get the cell to which the UAV should move
            
            if idx == None:
                #All of the valid cells have been fully searched (only happens if POD = 100%), so no further search is required.
                break
            else:
                #Calculate the energy necessary to move to the proposed cell, and if possible, add that cell the path of the UAV
                turn = calculate_turn_from_actions(cell.prev_action, next_cell.prev_action)
                distance = math.sqrt((next_cell.x - cell.x)**2 + (next_cell.y - cell.y)**2)
                energy_necessary = self.turn_weight*turn + self.distance_weight*distance
                if energies_rem[uav] > energy_necessary:
                    energies_rem[uav] -= energy_necessary
                    self.paths[uav].append(copy.deepcopy(next_cell))
                    self.valid_cell_list[idx].times_covered_prev += 1
                    self.paths_idx[uav].append(idx)
                    stopped_uavs[uav] = 0
                else:
                    stopped_uavs[uav] = 1
            uav += 1
    
    def calculate_turn(self, cell1, cell2, cell3):
        """Calculate the turn angle (in degrees), performed at cell2, that results from a path that visits cell1, cell2 and cell3 in this sequence."""
        vec1 = np.array([cell2.x-cell1.x, cell2.y-cell1.y])
        vec2 = np.array([cell3.x-cell2.x, cell3.y-cell2.y])
        cos_angle = np.dot(vec1, vec2)/(np.linalg.norm(vec1)*np.linalg.norm(vec2))
        cos_angle = round(cos_angle,4)
        angle = np.arccos(cos_angle)/np.pi*180
        return angle

class SimulatedAnnealing():
    """Class that describes the functions necessary for the implementation of the Simulated Annealing algorithm."""
    def __init__ (self, cell_list, d, type_init, number_threads, synchronism, initial_energies, number_uavs, pod):
        self.number_threads = number_threads
        self.number_uavs = number_uavs
        if number_threads <= 0:
            print("The number of threads must be a positive integer")
            exit()
        manager = multiprocessing.Manager()
        self.threads_paths = [manager.list([manager.list() for i in range(number_uavs)]) for i in range(number_threads)]
        #self.threads_paths = [[] for i in range(number_threads)]
        self.threads_paths_energy = multiprocessing.Array('f', [0 for i in range(number_threads)])
        self.threads_process_time = multiprocessing.Array('f', [0 for i in range(number_threads)])
        self.threads_time = multiprocessing.Array('f', [0 for i in range(number_threads)])
        self.thread_iteration = multiprocessing.Array('i', [0 for i in range(number_threads)])
        self.thread_last_update_iteration = multiprocessing.Array('i', [0 for i in range(number_threads)])
        self.synchronism = synchronism
        self.type_init = type_init
        self.initial_guess_list = []
        self.valid_cell_list = [cell for cell in cell_list if cell.status == 1]
        self.path = []
        self.d = d
        self.initial_energies = initial_energies
        self.adj_dict = {idx:[] for idx in range(len(self.valid_cell_list))}
        self.factor = 0.01
        self.turn_weight = 0.0173
        self.distance_weight = 0.1164
        self.min_energy = self.distance_weight * self.d
        self.neighbour_cases = [1,2,3,4,5]
        self.pod = pod

        self.L_k = 2653
        self.initial_temp = 1.83e-4
        self.cooling_factor = 0.954
        self.final_temp = 2.11e-5
        
        self.create_adjacency_dict()
        self.calculate_initial_guess(cell_list, initial_energies, number_uavs)
        
        self.my_lock = multiprocessing.Lock()
        self.threads_finished_loop_cond = multiprocessing.Condition(lock=self.my_lock)
    
    def create_adjacency_dict(self):
        """Fills in a dictionary with keys as cells indexes and values as a list of indexes of adjacent cells."""
        #Using 8 connected adjecency definition
        for idx1 in range(len(self.valid_cell_list)):
            for idx2 in range(idx1+1, len(self.valid_cell_list)):
                if check_if_cells_adjacent_8_conn(self.valid_cell_list[idx1], self.valid_cell_list[idx2]):
                    self.adj_dict[idx1].append(idx2)
                    self.adj_dict[idx2].append(idx1)
        #Create the dictionary entry for the pre-deployment state
        self.adj_dict[-1] = [idx for idx in range(len(self.valid_cell_list))]
    
    def calculate_initial_guess(self, cell_list, initial_energies, number_uavs):
        """Generates the initial solution guess to start the algorithm. A different initial solution is generated for each thread."""
        for i in range(self.number_threads):
            if self.type_init == 0:
                #Use attraction path as initial guess
                att = Attraction_algorithm(cell_list,self.d, initial_energies, number_uavs, self.pod)            
                att.generate_uav_path()
                self.initial_guess_list.append(att.paths)
            elif self.type_init == 1:
                #Bias the deployment positions towards cells with a high POC
                available_pos = [[cell.i,cell.j] for cell in self.valid_cell_list]
                initial_pos = random.choices(available_pos, weights = [cell.poc for cell in self.valid_cell_list], k = number_uavs)
                #Use random walk as initial guess
                aux_paths = []
                for j in range(number_uavs):
                    aux_paths.append(self.random_walk_initial_guess(initial_energies[j], initial_pos[j]))
                self.initial_guess_list.append(aux_paths)
    
    def random_walk_initial_guess(self, initial_energy, initial_cell_pos):
        """Generates a path for all of the UAVs using Random Walk (RW)."""
        step_distance = 0
        step_turns = 0
        energy_consumed = 0
        idx, aux = search_for_cell_ij(self.valid_cell_list, initial_cell_pos[0],initial_cell_pos[1])
        path = []
        while energy_consumed < initial_energy:
            path.append(self.valid_cell_list[idx])
            idx = random.choice(self.adj_dict[idx])
            step_distance = math.sqrt((path[-1].x - self.valid_cell_list[idx].x)**2 + (path[-1].y - self.valid_cell_list[idx].y)**2)
            if len(path) >= 2:
                step_turns = calculate_turn(path[-2], path[-1], self.valid_cell_list[idx]) #in degrees
            energy_consumed = energy_consumed + self.turn_weight*step_turns + self.distance_weight*step_distance
        return path
    
    def calculate_energy(self, paths):
        """Calculates the energy of a solution. In this case E = -J."""
        return -calculate_objective_multi(self.valid_cell_list, paths, self.pod, self.factor)
        
    def prob_accept(self, delta_E, T):
        """Calculates the probability of accepting a candidate solution."""
        return math.exp(delta_E/(T))
    
    def remove_node_mid(self, candidate):
        """Removes a random step from the middle of the path of a random UAV."""
        #Find a random node in the path
        aux = list(range(0,len(candidate)))
        random.shuffle(aux)
        while aux:
            idx = aux.pop()
            #If the selected node is the last OR if the selected node is the first and the initial position can be changed, remove it
            if idx == len(candidate)-1 or idx == 0:
                removed_cell_idx = candidate.pop(idx)
                return candidate
            #Check if the prev and next nodes are adjacent
            elif candidate[idx-1] in self.adj_dict[candidate[idx+1]]:
                removed_cell_idx = candidate.pop(idx)
                return candidate
        return candidate
    
    def change_node_position(self, candidate):
        """Changes the position of a random step in the path of a random UAV."""
        #Try different indexes until one is changed
        aux = list(range(0,len(candidate)))
        random.shuffle(aux)
        while aux:
            idx = aux.pop()
            if idx == len(candidate)-1: #In case the node selected to change is the last
                neighbours = copy.deepcopy(self.adj_dict[candidate[idx-1]])
                neighbours.remove(candidate[idx])
                if len(neighbours) != 0:
                    #Get a different final node and add it to the path
                    next_cell_idx = random.choice(neighbours)
                    candidate[idx] = next_cell_idx
                    return candidate
            elif idx == 0: #In case the node selected to change is in the start
                neighbours = copy.deepcopy(self.adj_dict[candidate[idx+1]])
                neighbours.remove(candidate[idx])
                if len(neighbours) != 0:
                    next_cell_idx = random.choice(neighbours)
                    candidate[idx] = next_cell_idx
                    return candidate
            else: #In case the node selected to change is in the middle
                #Get common neighbours between prev and next nodes
                neighbours_prev = self.adj_dict[candidate[idx-1]]
                neighbours_next = self.adj_dict[candidate[idx+1]]
                neighbours = [i for i in neighbours_prev if i in neighbours_next]
                neighbours.remove(candidate[idx])
                if len(neighbours) != 0:
                    next_cell_idx = random.choice(neighbours)
                    candidate[idx] = next_cell_idx
                    return candidate
        return candidate

    def add_node_mid(self, candidate):
        """Adds a step in a random position in the path of a random UAV."""
        #Find a random node in the path
        aux = list(range(0,len(candidate)-1)) #The selected node cant be the last since this one will probably be deleted
        random.shuffle(aux)
        while aux:
            idx = aux.pop()
            #Get common neighbours between prev and next nodes
            neighbours_prev = self.adj_dict[candidate[idx]]
            neighbours_next = self.adj_dict[candidate[idx+1]]
            neighbours = [i for i in neighbours_prev if i in neighbours_next and i != candidate[idx] and i != candidate[idx+1]]
            #print(neighbours)
            if len(neighbours) != 0:
                next_cell_idx = random.choice(neighbours)
                candidate.insert(idx+1, next_cell_idx)
                return candidate
        return candidate
    
    def change_initial_position(self, candidate, uav):
        """Changes the initial position of the path of a random UAV to one of the subsequent steps in its path."""
        #Change the initial position to any of the cells in the path
        new_start = random.choice(range(1,len(candidate[uav])))
        neighbour = copy.deepcopy(candidate[uav][new_start:])
        neighbour = self.adjust_path_batt(neighbour, uav)
        candidate[uav] = neighbour
        return candidate
    
    def add_node_end(self, candidate, energy_available):
        """Checks if the UAV has enough energy available at the end of the path to perform another step. It so, another step is added at the end."""
        if energy_available <self.min_energy:
            return candidate
        adj_sorted = copy.deepcopy(self.adj_dict[candidate[-1]])
        adj_sorted = sorted(adj_sorted, key = lambda x: self.valid_cell_list[x].poc, reverse = True)
        for cell_idx in adj_sorted:
            distance = math.sqrt((self.valid_cell_list[cell_idx].x - self.valid_cell_list[candidate[-1]].x)**2 + (self.valid_cell_list[cell_idx].y - self.valid_cell_list[candidate[-1]].y)**2)
            if len(candidate) >= 2:
                turns = calculate_turn(self.valid_cell_list[candidate[-2]], self.valid_cell_list[candidate[-1]], self.valid_cell_list[cell_idx])
            else:
                turns = 0
            extra_energy = self.turn_weight*turns+self.distance_weight*distance
            #print("extra_energy: ", extra_energy)
            if extra_energy < energy_available:
                candidate.append(cell_idx)
                candidate = self.add_node_end(candidate, energy_available-extra_energy)
                return candidate
        return candidate
    
    def check_if_valid_path(self, candidate):
        """Checks if the adjacency constraint is violated for a given path. Not used in the code, but useful for debugging."""
        for step in range(len(candidate)-1):
            if candidate[step+1] not in self.adj_dict[candidate[step]]:
                print("Problem at step ", step)
                print(candidate[step-2:step+3])
                return False
        return True
        
    def remove_path_crossing(self, candidate, case):
        """Removes an instance when the path of a random UAV crosses itself, or removes an instance when the paths of two random UAVs cross each other. A battery check and adjustment is performed at the end."""
        uav1 = random.randint(0,self.number_uavs-1)
        if case == 0:
            uav2 = random.randint(0,self.number_uavs-1)
        elif case == 1:
            uav2 = uav1
        elif case == 2:
            aux_list = list(range(0,self.number_uavs))
            aux_list.remove(uav1)
            uav2 = random.choice(aux_list)
        step_list = list(range(len(candidate[uav1])-1))

        for step in step_list:
            i1 = self.valid_cell_list[candidate[uav1][step]].i
            j1 = self.valid_cell_list[candidate[uav1][step]].j
            i2 = self.valid_cell_list[candidate[uav1][step+1]].i
            j2 = self.valid_cell_list[candidate[uav1][step+1]].j
            if abs(i1-i2)+abs(j1-j2) == 2: #step is diagonal
                for aux in range(len(candidate[uav2])-1):
                    i3 = self.valid_cell_list[candidate[uav2][aux]].i
                    j3 = self.valid_cell_list[candidate[uav2][aux]].j
                    i4 = self.valid_cell_list[candidate[uav2][aux+1]].i
                    j4 = self.valid_cell_list[candidate[uav2][aux+1]].j
                    if i1+i2 == i3+i4 and j1+j2 == j3+j4 and not (i1==i3 and j1==j3) and not (i1==i4 and j1==j4):
                        #The paths cross
                        if uav1 == uav2:
                            #Modifications within a single path
                            if step < aux:
                                aux_list = candidate[uav1][step+1:aux+1]
                                aux_list.reverse()
                                candidate[uav1][step+1:aux+1] = aux_list
                            else:
                                aux_list = candidate[uav1][aux+1:step+1]
                                aux_list.reverse()
                                candidate[uav1][aux+1:step+1] = aux_list
                        else:
                            #Modifications in different paths
                            aux_list1 = copy.deepcopy(candidate[uav1][:step+1] + candidate[uav2][aux+1:])
                            aux_list2 = copy.deepcopy(candidate[uav2][:aux+1] + candidate[uav1][step+1:])
                            aux_list1 = self.adjust_path_batt(aux_list1, uav1)
                            aux_list2 = self.adjust_path_batt(aux_list2, uav2)
                            candidate[uav1]= aux_list1
                            candidate[uav2]= aux_list2
                        return candidate
        return candidate
    
    def adjust_path_batt(self, candidate, uav):
        """If the path's energy demands excede the energy available to the UAV, remove steps from the end. The the UAV still has enough energy available at the end of the path, add further steps in its path if possible."""
        path = [self.valid_cell_list[idx] for idx in candidate]
        step_distance = 0
        step_turns = 0
        energy_consumed = 0
        for idx in range(len(path)-1):
            step_distance = math.sqrt((path[idx+1].x - path[idx].x)**2 + (path[idx+1].y - path[idx].y)**2)
            if idx != 0:
                step_turns = calculate_turn(path[idx-1], path[idx], path[idx+1]) #in degrees
            energy_consumed = energy_consumed + self.turn_weight*step_turns + self.distance_weight*step_distance
            #If the there is no more energy available, take out the rest of the path
            if energy_consumed > self.initial_energies[uav]:
                return candidate[0:idx]
        #If we get to this point, we still have enough energy for another step
        candidate = self.add_node_end(candidate, self.initial_energies[uav]-energy_consumed)
        return candidate
    
    def get_indexes(self, paths):
        """Converts a path represented as a list of cell objects into a list of the corresponding indexes in the valid_cell_list."""
        paths_idx = []
        for path in paths:
            path_idx = []
            for cell in path:
                idx, aux = search_for_cell_ij(self.valid_cell_list, cell.i,cell.j)
                path_idx.append(idx)
            paths_idx.append(path_idx)
        return paths_idx
    
    def get_random_neighbour(self, accepted_path):
        """Generates a random neighbour solution to the currently accepted solution."""
        candidate = copy.deepcopy(accepted_path)
        case = random.choice(self.neighbour_cases)
        uav = random.randint(0,self.number_uavs-1)
        if case == 1:
            #Remove a node form the middle of the path
            candidate[uav] = self.remove_node_mid(candidate[uav])
            #Check if new path doesnt excede the UAV battery constraint
            candidate[uav] = self.adjust_path_batt(candidate[uav], uav)
        elif case == 2:
            #Change the position of a node in the middle of the path
            candidate[uav] = self.change_node_position(candidate[uav])
            #Check if new path doesnt excede the UAV battery constraint
            candidate[uav] = self.adjust_path_batt(candidate[uav], uav)
        elif case == 3:
            #Add a node in the middle of the path
            candidate[uav] = self.add_node_mid(candidate[uav])
            #Check if new path doesnt excede the UAV battery constraint
            candidate[uav] = self.adjust_path_batt(candidate[uav], uav)
        elif case == 4:
            #If a cross with no common cell is detected, change the path terminations
            candidate = self.remove_path_crossing(candidate, 0) #battery adjustment done inside
        elif case == 5:
            #Change the starting position of a path
            candidate = self.change_initial_position(candidate, uav)
            
        #In the case 1 it happens a lot that the node to be removed is the last and the candidate is the same as the path
        if (case == 1 or case == 4 or case == 5) and candidate == accepted_path:
            case = random.randint(2,3)
            if case == 2:
                #Change the position of a node in the middle of the path
                candidate[uav] = self.change_node_position(candidate[uav])
                candidate[uav] = self.adjust_path_batt(candidate[uav], uav)
            elif case == 3:
                #Add a node in the middle of the path
                candidate[uav] = self.add_node_mid(candidate[uav])
                candidate[uav] = self.adjust_path_batt(candidate[uav], uav)
        
        return candidate
    
    def thread_is_behind(self, curr_thread_idx):
        """Checks if a thread is behind or ahead of the other threads, in terms of the number of times that the temperature has been reduced."""
        if all([self.thread_iteration[curr_thread_idx] <= thread_iter for thread_iter in self.thread_iteration[0:self.number_threads]]):
            return True
        else:
            return False
        
    def all_threads_synched(self, curr_thread_idx):
        """Check if all of the threads have reduced their temperature the same number of times, before updating its own accepted solution in the shared memory."""
        if all([self.thread_last_update_iteration[curr_thread_idx] == last_update_iter for last_update_iter in self.thread_last_update_iteration[0:self.number_threads]]):
            return True
        else:
            return False
    
    def all_threads_at_same_iter(self, curr_thread_idx):
        """Checks if all of the threads have updated their accepted solutions before starting to compare them."""
        if all([self.thread_iteration[curr_thread_idx] == thread_iter for thread_iter in self.thread_iteration[0:self.number_threads]]):
            return True
        else:
            return False
    
    def run_SA_in_thread(self, thread_idx, threads_path, threads_finished_loop_cond):
        """Run the single-threaded SA algorithm inside each thread."""
        thread_start_time = time.time()
        thread_start_process_time = time.process_time()
        #Get idx in path
        accepted_path = self.get_indexes(self.initial_guess_list[thread_idx])
        energy = self.calculate_energy(accepted_path)
        c_k = self.initial_temp
        
        iterations = 0
        energy_list = []
        energy_list.append(energy)

        while c_k > self.final_temp: #Termination condition
            candidate_path_energy = []
            for i in range(self.L_k):
                #randomly choose a modification to perform on the path
                candidate = self.get_random_neighbour(accepted_path)
                #Calculate the energy of this new path
                energy_new = self.calculate_energy(candidate)
                candidate_path_energy.append(energy_new)
                if energy_new < energy or random.random() < self.prob_accept(energy - energy_new, c_k):
                    energy = energy_new
                    accepted_path = copy.deepcopy(candidate)

            c_k = c_k * self.cooling_factor
            
            energy_list.append(energy)
            iterations += 1
            if self.synchronism == 1:
                #Acquires the lock
                with self.threads_finished_loop_cond:
                    #If the thread is ahead of schedule, wait, otherwise move on
                    while not self.thread_is_behind(thread_idx):
                        self.threads_finished_loop_cond.wait()
                    #Changes the iterations array
                    self.thread_iteration[thread_idx] = iterations
                    self.threads_finished_loop_cond.notify_all()
                    while not self.all_threads_synched(thread_idx):
                        self.threads_finished_loop_cond.wait()
                    #Changes its current accepted path
                    threads_path[:] = accepted_path
                    #Updates its current accepted path energy
                    self.threads_paths_energy[thread_idx] = energy
                    #Notify any remaining waiting threads
                    self.threads_finished_loop_cond.notify_all()
                    #Wait for all threads to complete the iteration before comparing results
                    while not self.all_threads_at_same_iter(thread_idx):
                        self.threads_finished_loop_cond.wait()
                    #Find the best path and copy it and its energy
                    min_energy = min(self.threads_paths_energy[0:self.number_threads])
                    min_energy_thread_idx = list(self.threads_paths_energy[0:self.number_threads]).index(min_energy)
                    threads_path[:] = self.threads_paths[min_energy_thread_idx]
                    
                    self.thread_last_update_iteration[thread_idx] = iterations
                    
                    self.threads_paths_energy[thread_idx] = min_energy
                    self.threads_finished_loop_cond.notify_all()
                    
        if self.synchronism == 0:
            threads_path[:] = accepted_path
            self.threads_paths_energy[thread_idx] = energy

        thread_end_process_time = time.process_time()
        thread_end_time = time.time()
        self.threads_process_time[thread_idx] = thread_end_process_time-thread_start_process_time
        self.threads_time[thread_idx] = thread_end_time-thread_start_time
        
    
    def generate_uav_path(self, save_res, filename):
        """Generate the paths of the UAVs using the SA algorithm."""
        
        my_lock = multiprocessing.Lock()
        threads_finished_loop_cond = multiprocessing.Condition(lock=my_lock)
        thread_idx = 0
        thread_list = []
        #Run the SA algorithm in the specified number of threads
        for thread_idx in range(self.number_threads):
            aux_thread = multiprocessing.Process(target=self.run_SA_in_thread, args=(thread_idx, self.threads_paths[thread_idx],threads_finished_loop_cond,))
            aux_thread.start()
            thread_list.append(aux_thread)
        
        #Wait for the threads to finish
        for aux_thread in thread_list:
            aux_thread.join()

        #Get the result from the thread that produced the best path
        best_path_energy = min(self.threads_paths_energy)
        for i in range(self.number_threads):
            if self.threads_paths_energy[i] == best_path_energy:
                break
        #best_thread_indx = self.threads_paths_energy.index(best_path_energy)
        accepted_path = self.threads_paths[i]
        if save_res==1:
            f = open('./results/' + filename+'.txt', "a")
            f.write("\nUsing the Simulated Annealing algorithmn\n")
            if self.type_init == 0:
                f.write("Initial guess generated using the Attraction algorithm.\n")
            elif self.type_init == 1:
                f.write("Initial guess generated using Random walk.\n")
            f.write("Initial temp: " + str(self.initial_temp) + '\n')
            f.write("L_k: " + str(self.L_k) + '\n')
            f.write("Final temp: " + str(self.final_temp) + '\n')
            f.write("cooling factor: " + str(self.cooling_factor) + '\n')
            f.write("Number of UAVs: " + str(self.number_uavs) + '\n')
            f.write("Energies available: " + str(self.initial_energies) + '\n')
            f.write("Number of threads: " + str(self.number_threads) + " Synchronism: "+ str(self.synchronism) + '\n')
            f.write("Threads path J results: " + str(list(self.threads_paths_energy[0:self.number_threads])) + '\n')
            f.write("Accepted path J: " + str(best_path_energy) + '\n')
            f.write("Path accepted: " + str(accepted_path) + '\n')
            f.write("Max thread processing time: " + str(max(self.threads_process_time)) + '\n')
            f.write("Sum of threads processing time: " + str(sum(self.threads_process_time)) + '\n')
            f.write("Max thread wall-clock time: " + str(max(self.threads_time)) + '\n')
            f.write("Sum of threads wall-clock time: " + str(sum(self.threads_time)) + '\n')
            f.close()

        self.paths_idx = copy.deepcopy(accepted_path)
        self.paths = [[self.valid_cell_list[idx] for idx in aux_path] for aux_path in accepted_path]

class AntColonyOpt():
    """Class that describes the functions necessary for the implementation of the Ant Colony Optimization algorithm."""
    def __init__(self, cell_list, d, initial_energies, number_uavs, pod):
        self.number_uavs = number_uavs
        self.valid_cell_list = [cell for cell in cell_list if cell.status == 1]
        self.max_poc = max(cell.poc for cell in self.valid_cell_list)
        self.min_poc = min(cell.poc for cell in self.valid_cell_list)
        self.sum_poc = sum(cell.poc for cell in self.valid_cell_list)
        self.n_valid_cells = len(self.valid_cell_list)
        self.d = d
        self.initial_energies = initial_energies

        self.adj_dict = {idx:[] for idx in range(len(self.valid_cell_list))}
        self.create_adjacency_dict()
        
        self.curr_iter = 0
        self.pod = pod
        self.factor = 0.01
        self.turn_weight = 0.0173
        self.distance_weight = 0.1164
        self.d = d
        self.max_energy = self.distance_weight * self.d * math.sqrt(2) + 180*self.turn_weight
        
        self.max_iterations = 10000
        self.alpha = 2.73
        self.beta = 19.96
        self.evaporation =  0.690
        self.Q = 9.56
        self.min_heuristic = 9.31e-7
        
        self.number_of_nodes = 0
        self.root_node = None

    def create_adjacency_dict(self):
        """Fills in a dictionary with keys as cells indexes and values as a list of indexes of adjacent cells"""
        #Using 8 connected definition
        for idx1 in range(len(self.valid_cell_list)):
            for idx2 in range(idx1+1, len(self.valid_cell_list)):
                if check_if_cells_adjacent_8_conn(self.valid_cell_list[idx1], self.valid_cell_list[idx2]):
                    self.adj_dict[idx1].append(idx2)
                    self.adj_dict[idx2].append(idx1)
        #Create the dictionary entre for the first virtual node
        self.adj_dict[-1] = [idx for idx in range(len(self.valid_cell_list))]

    def get_final_path(self):
        """Places an ant on the root node, and traverses the tree choosing the nodes that have the highest pheromone value. Returns the resulting UAV paths."""
        current_node = self.root_node
        paths_idx = [[] for _ in range(self.number_uavs)]
        while(self.is_not_terminal(current_node)):
            max_child = max(current_node.children, key=lambda x: x.pheromones)
            paths_idx[max_child.last_uav_idx].append(max_child.cells_idx[max_child.last_uav_idx])
            current_node = max_child
        
        return paths_idx
    
    def generate_uav_path(self, save_fig=0, fig_name=''):
        """Generates the paths for the available UAVs using the ACO algorithm."""
        initial_cells = [-1 for _ in range(self.number_uavs)]
        self.root_node = ACO_Node(initial_cells, self.initial_energies, self.number_uavs-1, 0, self.evaporation)

        self.curr_iter = 0
        #Run in a loop until the termination condition is met
        while self.curr_iter < self.max_iterations:
            #Generate a full path starting at the root
            current_node = self.root_node

            while(self.is_not_terminal(current_node)):
                if len(current_node.children) == 0:
                    #The node is not terminal but hasnt been expanded yet
                    self.expand_node(current_node)
                
                #Choose one of the children as the next node
                current_node = self.choose_child(current_node)
            
            #The pheromone evaporation is done passively every time a node is checked out.
            #When the algorithm need to check the pheromones deposited in a given node, those pheromones are updated to account for the evaporation.
            
            #Deposit the pheromones from the last path
            self.deposit_pheromones_from_last_node(current_node)

            self.curr_iter += 1
        
        #Place the special ant in the root node and traverses the tree one last time to get the final UAV paths
        self.paths_idx = self.get_final_path()
        self.paths = [[self.valid_cell_list[cell_idx] for cell_idx in path] for path in self.paths_idx]
        
        if save_fig==1:
            f = open('./results/' + fig_name+'.txt', "a")
            f.write("Using AntColonyOpt_v2 algorithm\n")
            f.write("Paths: " + str(self.paths_idx) + '\n')
            f.write("Total number of nodes explored: " + str(self.number_of_nodes) + '\n')
            f.write("Q*max_iter = " + str(self.Q*self.max_iterations) + "\n")
            f.write("Q = " + str(self.Q) + "\n")
            f.write("max_iter = " + str(self.max_iterations) + "\n")
            f.write("alpha = " + str(self.alpha) + "\n")
            f.write("beta = " + str(self.beta) + "\n")
            f.write("evaporation = " + str(self.evaporation) + "\n")
            f.close()
        
        return self.paths
        
    def is_not_terminal(self, node):
        """Returns False if a node is terminal, and True otherwise. A node is considered to be terminal if none of the available UAVs has enough energy to perform another step."""
        if len(node.children) != 0:
            return True
        #A terminal node is also reached if all the cells have been visited
        visited_list = []
        aux_node = node
        while(aux_node is not None):
            for uav in range(self.number_uavs):
                if aux_node.cells_idx[uav] not in visited_list and aux_node.cells_idx[uav] != -1:
                    visited_list.append(aux_node.cells_idx[uav])
            aux_node = aux_node.parent
        
        if len(visited_list)==len(self.valid_cell_list):
            return False
        
        if any(energy_rem > self.max_energy for energy_rem in node.uavs_energy_rem):
            return True
        
        #A terminal node is reached if none of the UAVs have energy left for more moves
        for uav in range(self.number_uavs):
            current_cell = node.cells_idx[uav]
            prev_cell = self.get_prev_cell(node, uav)
            for next_cell in self.adj_dict[current_cell]:
                if node.uavs_energy_rem[uav] > self.energy_necessary(prev_cell,current_cell,next_cell):
                    return True
        return False
    
    def expand_node(self, node):
        """Expands the node passed as an argument. It generates a child node for each action that can be taken by the selected UAV."""
        #Fully expands the current node
        current_node = node
        move_priority = list(range(current_node.last_uav_idx+1, self.number_uavs)) + list(range(0,current_node.last_uav_idx+1))
        
        for uav in move_priority:
            #Check if the expected next UAV has enough energy available and if yes, expand for that one
            possible_moves = self.possible_moves(current_node, uav)
            if len(possible_moves) > 0:
                break #uav is now one that can move
        
        for action in possible_moves: #check if all its possible moves have been performed
            
            positions = [pos if i != uav else action for i, pos in enumerate(current_node.cells_idx)]
            
            current_cell = current_node.cells_idx[uav]
            prev_cell = self.get_prev_cell(current_node, uav)
            next_cell = action
            energy_rem = copy.deepcopy(current_node.uavs_energy_rem)
            energy_rem[uav] = current_node.uavs_energy_rem[uav] - self.energy_necessary(prev_cell,current_cell,next_cell)
            
            new_node = ACO_Node(positions, energy_rem, uav, self.curr_iter, self.evaporation, current_node)
            node.children.append(new_node)
            
            self.number_of_nodes += 1
    
        return node.children
    
    
    def possible_moves(self, node, uav):
        """Creates a list of the actions that can be taken by the selected UAV, given its adjacent cells and its energy available."""
        moves = []
        current_cell = node.cells_idx[uav]
        prev_cell = self.get_prev_cell(node, uav)
        for next_cell in self.adj_dict[current_cell]:
            if node.uavs_energy_rem[uav] > self.energy_necessary(prev_cell,current_cell,next_cell):
                moves.append(next_cell)
        return moves
    
    def get_prev_cell(self, node, uav):
        """Returns the second-to-last cell in the path of the selected UAV."""
        current_cell = node.cells_idx[uav]
        aux_node = node.parent
        while(aux_node is not None):
            if aux_node.cells_idx[uav] != current_cell:
                return aux_node.cells_idx[uav]
            aux_node = aux_node.parent
        return current_cell
    
    def energy_necessary(self, prev_cell, current_cell, next_cell):
        """Calculates the energy necessary to perform a given action."""
        return self.distance_weight*self.calculate_distance(current_cell, next_cell) + self.turn_weight*self.calculate_turn(prev_cell,current_cell,next_cell)
    
    def calculate_distance(self, cell1_idx, cell2_idx):
        """Calculates the distance between two cells."""
        if cell1_idx == -1:
            return 0
        cell1 = self.valid_cell_list[cell1_idx]
        cell2 = self.valid_cell_list[cell2_idx]
        return math.sqrt((cell1.x-cell2.x)**2+(cell1.y-cell2.y)**2)

    def calculate_turn(self, cell1_idx, cell2_idx, cell3_idx):
        """Calculate the degrees involved in turing from cell1, 2 and 3."""
        if cell1_idx == -1 or cell2_idx == -1:
            return 0
        
        cell1 = self.valid_cell_list[cell1_idx]
        cell2 = self.valid_cell_list[cell2_idx]
        cell3 = self.valid_cell_list[cell3_idx]
        
        vec1 = np.array([cell2.x-cell1.x, cell2.y-cell1.y])
        vec2 = np.array([cell3.x-cell2.x, cell3.y-cell2.y])
        
        if (np.linalg.norm(vec1)*np.linalg.norm(vec2)) == 0:
            sys.exit('Cells are repeated in the path')
        else:
            cos_angle = np.dot(vec1, vec2)/(np.linalg.norm(vec1)*np.linalg.norm(vec2))
            cos_angle = round(cos_angle,4)
            angle = np.arccos(cos_angle)/np.pi*180
        return angle #in degrees
    
    def choose_child(self, node, deterministic = False):
        """Choose the child node to which the ant is going to move, based on the ant decision formula."""
        p_children = []
        for child in node.children:
            new_cell_idx = child.cells_idx[child.last_uav_idx]
            pos_cumulative = (1-self.pod)**child.n_times_visited_prev * self.pod * self.valid_cell_list[new_cell_idx].poc
            heuristic = self.min_heuristic + pos_cumulative        
            pheromones = child.update_and_get_pheromones(self.curr_iter, self.evaporation)
            prob = pheromones**self.alpha * heuristic ** self.beta
            p_children.append(prob)
        
        sum_prob = sum(p_children)
        p_children = [p/sum_prob for p in p_children]
        
        if deterministic:
            max_value = max(p_children)
            max_child_idx = p_children.index(max_value)
            return node.children[max_child_idx]
            
        next_node = random.choices(node.children, weights=p_children)[0]
        return next_node
    
    def calculate_objective_func_from_last_node(self, last_node):
        """Calculates the objective function value of the UAV paths that correspond to the tree node path that ends in last_node."""
        paths_idx = [[] for _ in range(self.number_uavs)]
        #paths_idx[max_child.last_uav_idx].append(max_child.cells_idx[max_child.last_uav_idx])
        path = last_node.get_nodes_in_path()
        for node in path[1:]:
            paths_idx[node.last_uav_idx].append(node.cells_idx[node.last_uav_idx])
        
        objective = calculate_objective_multi(self.valid_cell_list, paths_idx, self.pod, self.factor)
        return objective
    
    def deposit_pheromones_from_last_node(self, last_node):
        """Deposits the pheromones in all of the nodes in the tree path that ends in last_node."""
        objective_func = self.calculate_objective_func_from_last_node(last_node)
        aux_node = last_node
        while(aux_node is not None):
            #aux_node.pheromones += self.Q*objective_func
            aux_node.update_and_get_pheromones(self.curr_iter, self.evaporation, self.Q*objective_func)
            aux_node = aux_node.parent

class MonteCarloTreeSearch():
    """Class that describes the functions necessary for the implementation of the Monte Carlo Tree Search algorithm."""
    def __init__(self, cell_list, d, initial_energies, number_uavs, pod):
        self.number_uavs = number_uavs
        self.initial_guess_list = []
        self.valid_cell_list = [cell for cell in cell_list if cell.status == 1]
        self.paths = []
        self.paths_idx = []
        self.d = d
        self.initial_energies = initial_energies
        self.adj_dict = {idx:[] for idx in range(len(self.valid_cell_list))}
        self.factor = 0.01
        self.turn_weight = 0.0173
        self.distance_weight = 0.1164
        self.number_of_nodes = 0
        self.number_of_iterations = 0
        self.pod = pod
        self.final_node_selection = 0 #0 - max child, 1 - robust child, 2 - secure child
        self.A = 4 #only used in the secure child case
        self.n_rollouts_per_sim = 1
        self.c = 1e-12
        self.terminal_state_reached = 0
        
        self.create_adjacency_dict()
        
    def create_adjacency_dict(self):
        """Fills in a dictionary with keys as cells indexes and values as a list of indexes of adjacent cells"""
        #Using 8 connected definition
        for idx1 in range(len(self.valid_cell_list)):
            for idx2 in range(idx1+1, len(self.valid_cell_list)):
                if check_if_cells_adjacent_8_conn(self.valid_cell_list[idx1], self.valid_cell_list[idx2]):
                    self.adj_dict[idx1].append(idx2)
                    self.adj_dict[idx2].append(idx1)
        #Create the dictionary entre for the first virtual node
        self.adj_dict[-1] = [idx for idx in range(len(self.valid_cell_list))]        
    
    def get_prev_cell(self, node, uav):
        """Returns the second-to-last cell in the path of the selected UAV."""
        current_cell = node.cells_idx[uav]
        aux_node = node.parent
        while(aux_node is not None):
            if aux_node.cells_idx[uav] != current_cell:
                return aux_node.cells_idx[uav]
            aux_node = aux_node.parent
        return current_cell
        
    def calculate_turn(self, cell1_idx, cell2_idx, cell3_idx):
        """Calculate the degrees involved in turing from cell1, 2 and 3"""
        if cell1_idx == -1 or cell2_idx == -1:
            return 0
        
        cell1 = self.valid_cell_list[cell1_idx]
        cell2 = self.valid_cell_list[cell2_idx]
        cell3 = self.valid_cell_list[cell3_idx]
        
        vec1 = np.array([cell2.x-cell1.x, cell2.y-cell1.y])
        vec2 = np.array([cell3.x-cell2.x, cell3.y-cell2.y])
        
        if (np.linalg.norm(vec1)*np.linalg.norm(vec2)) == 0:
            sys.exit('Cells are repeated in the path')
        else:
            cos_angle = np.dot(vec1, vec2)/(np.linalg.norm(vec1)*np.linalg.norm(vec2))
            cos_angle = round(cos_angle,4)
            angle = np.arccos(cos_angle)/np.pi*180
        return angle #in degrees
    
    def calculate_distance(self, cell1_idx, cell2_idx):
        """Calculates the distance between two valid cells."""
        if cell1_idx == -1:
            return 0
        cell1 = self.valid_cell_list[cell1_idx]
        cell2 = self.valid_cell_list[cell2_idx]
        return math.sqrt((cell1.x-cell2.x)**2+(cell1.y-cell2.y)**2)
    
    def energy_necessary(self, prev_cell, current_cell, next_cell):
        """Calculates the energy necessary for a UAV to travel from current_cell to next_cell."""
        return self.distance_weight*self.calculate_distance(current_cell, next_cell) + self.turn_weight*self.calculate_turn(prev_cell,current_cell,next_cell)
        
    def is_not_terminal(self, node):
        """Returns False if a node is terminal, and True otherwise. A node is considered to be terminal if none of the available UAVs has enough energy to perform another step."""
        for uav in range(self.number_uavs):
            current_cell = node.cells_idx[uav]
            prev_cell = self.get_prev_cell(node, uav)
            for next_cell in self.adj_dict[current_cell]:
                if node.uavs_energy_rem[uav] > self.energy_necessary(prev_cell,current_cell,next_cell):
                    return True
        return False
    
    def possible_moves(self, node, uav):
        """Creates a list of the actions that can be taken by the selected UAV, given its adjacent cells and its energy available."""
        moves = []
        current_cell = node.cells_idx[uav]
        prev_cell = self.get_prev_cell(node, uav)
        for next_cell in self.adj_dict[current_cell]:
            if node.uavs_energy_rem[uav] > self.energy_necessary(prev_cell,current_cell,next_cell):
                moves.append(next_cell)
        return moves
    
    def best_child(self, node, C):
        """Selects a child node according to the UCT tree policy, adapted for combinatorial search problems."""
        not_fully_explored_list = [aux_node for aux_node in node.children if aux_node.fully_explored == 0]
        
        max_child = not_fully_explored_list[0]
        max_value = max_child.Q_max + C*math.sqrt(2*math.log(node.N)/max_child.N)
        
        for child in not_fully_explored_list:
            value = child.Q_max + C*math.sqrt(2*math.log(node.N)/child.N)
            if max_value < value:
                max_value = value
                max_child = child
        
        return max_child

    def tree_policy(self, node):
        """Performs the Selection and Expansion steps of the MCTS algorithm, traversing the tree and expanding a node when a leaf node is found."""
        current_node = node
        while self.is_not_terminal(current_node):
            
            if current_node.fully_expanded == 0:
                move_priority = list(range(current_node.last_uav_idx+1, self.number_uavs)) + list(range(0,current_node.last_uav_idx+1))
                
                for uav in move_priority:
                    #Check if the expected next UAV has enough energy available and if yes, expand for that one
                    possible_moves = self.possible_moves(current_node, uav)
                    if len(possible_moves) > 0:
                        break #uav is now one that can move
            
                #Expand the node
                positions = copy.deepcopy(current_node.cells_idx)
                #Choose an action that will result in a child that hasnt been explored
                explored_actions = [aux_node.cells_idx[uav] for aux_node in current_node.children]
                for action in possible_moves:
                    if action not in explored_actions:
                        positions[uav] = action
                        break
                
                current_cell = current_node.cells_idx[uav]
                prev_cell = self.get_prev_cell(current_node, uav)
                next_cell = action
                energy_rem = copy.deepcopy(current_node.uavs_energy_rem)
                energy_rem[uav] = current_node.uavs_energy_rem[uav] - self.energy_necessary(prev_cell,current_cell,next_cell)
                
                new_node = MCS_Node(positions, energy_rem, uav, current_node)
                self.number_of_nodes += 1
                
                if not self.is_not_terminal(new_node): #If the expanded node is terminal, then all of its children have been explored
                    new_node.fully_explored = 1
                    new_node.fully_expanded = 1
                
                current_node.children.append(new_node)
                if len(current_node.children) == len(possible_moves):
                    current_node.fully_expanded = 1 #The current node is finally fully expanded after the last child was created
                
                return new_node
            else:
                #All the childs have been found, so get the next node
                current_node = self.best_child(current_node, self.c)
            
        return current_node
    
    def get_paths_until_node(self, node):
        """Returns the UAV paths that correspond to the tree node path that ends in node."""
        node_path = node.get_nodes_in_path()
        paths_idx = [[] for i in range(self.number_uavs)]
        
        if len(node_path) <= 1:
            return paths_idx
        
        for aux_node in node_path[1:]:
            last_moved_uav = aux_node.last_uav_idx
            last_moved_cell = aux_node.cells_idx[last_moved_uav]
            paths_idx[last_moved_uav].append(last_moved_cell)
        
        return paths_idx #Does not include -1
    
    def get_next_cell_greedy(self, cell_idx, visited_cells):
        """Selects the cell with the highest POS among all of the neighbors of the cell with index cell_idx."""
        #Finds the next cell to visit in the simulated path
        neighbours = self.adj_dict[cell_idx]
        bias_neighbours = [(1-self.pod)**visited_cells[i]*self.pod*self.valid_cell_list[i].poc for i in neighbours]
        if sum(bias_neighbours) == 0:
            next_cell_idx = random.choice(neighbours)
        else:
            max_bias_idx = bias_neighbours.index(max(bias_neighbours))
            next_cell_idx = neighbours[max_bias_idx]
        return next_cell_idx
    
    def simulate_path_from_last_node(self, node):
        """Generates a rollout during the Simulation step of the MCTS algorithm."""
        paths_idx = self.get_paths_until_node(node)
        energies_rem = copy.deepcopy(node.uavs_energy_rem)
        stopped_uavs = [0 for i in range(self.number_uavs)]
        
        visited_cells = {i:0 for i in range(len(self.valid_cell_list))}
        for aux_path in paths_idx:
            for aux_cell in aux_path:
                visited_cells[aux_cell] += 1
        
        uav = node.last_uav_idx + 1
        while(1):
            if all(stopped_uavs):
                counter += 1
                if counter == self.number_uavs:
                    break
            else:
                counter = 0
            if uav == self.number_uavs:
                uav = 0
            
            if len(paths_idx[uav]) == 0:
                current_cell = -1
                prev_cell = -1
            elif len(paths_idx[uav]) == 1:
                current_cell = paths_idx[uav][-1]
                prev_cell = -1
            else:
                current_cell = paths_idx[uav][-1]
                prev_cell = paths_idx[uav][-2]
            
            
            next_cell = self.get_next_cell_greedy(current_cell, visited_cells)
            
            energy_necessary = self.energy_necessary(prev_cell, current_cell, next_cell)

            if energies_rem[uav] > energy_necessary:
                energies_rem[uav] -= energy_necessary
                paths_idx[uav].append(next_cell)
                visited_cells[next_cell] += 1
                stopped_uavs[uav] = 0
            else:
                stopped_uavs[uav] = 1
            uav += 1
        return paths_idx
    
    def default_policy(self, node):
        """Performs a rollout and calculates the objective function of the resulting UAV path."""
        rewards = []
        for _ in range(self.n_rollouts_per_sim):
            #Simulate a case for the rest of the path
            paths_idx = self.simulate_path_from_last_node(node)
            #Calculate the objective function for these
            reward = calculate_objective_multi(self.valid_cell_list, paths_idx, self.pod, self.factor)
            rewards.append(reward)
        avg_rewards = sum(rewards)/len(rewards)
        return avg_rewards
    
    def backup_reward(self, current_node, reward):
        """Propagates the reward obtained from the rollout to the nodes in the tree path."""
        aux_node = current_node
        while (aux_node is not None):
            aux_node.N = aux_node.N + 1
            aux_node.Q = aux_node.Q + reward
            
            if aux_node.Q_max < reward:
                aux_node.Q_max = reward
                if aux_node.Q_max_max < reward:
                    aux_node.Q_max_max = reward
            
            check_parent_fully_explored = aux_node.fully_explored #If the current node is fully explored, check if its parent is now fully explored
            
            aux_node = aux_node.parent
            
            if check_parent_fully_explored and (aux_node is not None):
                if aux_node.fully_expanded == 1:
                    aux_node.fully_explored = int(all(child.fully_explored for child in aux_node.children))
        
        #If the last node is fully explored, change the Q_max of the nodes in the path to eliminate the influence of the path that has already been fully explored
        aux_node = current_node.parent
        if (aux_node is not None) and aux_node.fully_explored:
            aux_node = aux_node.parent
            while (aux_node is not None):
                not_fully_explored_children = [child for child in aux_node.children if child.fully_explored == 0]
                if len(not_fully_explored_children) != 0:
                    aux_node.Q_max = max(child.Q_max for child in not_fully_explored_children)
                aux_node = aux_node.parent
    
    def calculate_eff_branching_factor(self):
        d = self.sol_depth
        N = self.number_of_nodes
        func = lambda B: ((B)**(d+1) - 1) / (B - 1) - N+1
        
        initial_guess = N**(1/d)
        
        eff_branching_factor = fsolve(func, initial_guess)
        return eff_branching_factor
    
    def max_child(self, node):
        """Policy used to traverse the tree after the MCTS termination condition was triggered, in order to find the best node path. Returns the child node that has the highest lower bound on the reward."""
        max_child = node.children[0]
        max_value = max_child.Q_max_max
        
        for child in node.children:
            value = child.Q_max_max
            if max_value < value:
                max_value = value
                max_child = child
        
        return max_child
        
    def robust_child(self, node):
        """Policy used to traverse the tree after the MCTS termination condition was triggered, in order to find the best node path."""
        n_visits_list = [child.N for child in node.children]
        max_visits_idx = n_visits_list.index(max(n_visits_list))
        aux_node = node.children[max_visits_idx]
        return aux_node

    def secure_child(self, node):
        """Policy used to traverse the tree after the MCTS termination condition was triggered, in order to find the best node path."""
        max_child = node.children[0]
        max_value = max_child.Q_max_max + self.A/math.sqrt(max_child.N)
        
        for child in node.children:
            value = child.Q_max_max + self.A/math.sqrt(child.N)
            if max_value < value:
                max_value = value
                max_child = child
        
        return max_child
        
    
    def generate_uav_path(self, time_limit, save_fig=0, fig_name=''):
        """Generates the paths of available UAVs using the MCTS algorithm."""
        initial_cells = [-1 for i in range(self.number_uavs)]
        #Create the root node - all the UAVs are in a virtual cell that can access anywhere in the space
        root_node = MCS_Node(initial_cells, self.initial_energies, self.number_uavs-1)
        initial_time = time.process_time()
        self.number_of_nodes = 1
        self.number_of_iterations = 0
        while time.process_time() - initial_time < time_limit:
            if root_node.fully_explored == 1: #The tree has been fully explored - stop the iterations
                print("Tree fully explored!!")
                break
            current_node = self.tree_policy(root_node)
            reward = self.default_policy(current_node)
            self.backup_reward(current_node, reward)
            self.number_of_iterations += 1
            
        self.sol_depth = 0
        aux_node = root_node
        while len(aux_node.children) != 0:
            if self.final_node_selection == 0:
                aux_node = self.max_child(aux_node)
            elif self.final_node_selection == 1:
                aux_node = self.robust_child(aux_node)
            elif self.final_node_selection == 2:
                aux_node = self.secure_child(aux_node)
            self.sol_depth += 1
        
        
        #Check if a terminal state was reached, and if not perform a rollout from it and output the result
        self.terminal_state_reached = not self.is_not_terminal(aux_node)
        if self.terminal_state_reached:
            self.paths_idx = self.get_paths_until_node(aux_node)
        else:
            self.paths_idx =  self.simulate_path_from_last_node(aux_node) #Perform a rollout from the last node
        
        self.paths = [[self.valid_cell_list[cell_idx] for cell_idx in path] for path in self.paths_idx]

        if save_fig==1:
            f = open('./results/' + fig_name+'.txt', "a")
            f.write("Using MCS algorithm with greedy tree policy Q_max not repeating nodes changing Q_max\n")
            f.write("c: " + str(self.c) + '\n')
            f.write("terminal state reached: " + str(self.terminal_state_reached) + '\n')
            f.write("number of rollouts per sim: " + str(self.n_rollouts_per_sim) + '\n')
            f.write("Paths: " + str(self.paths_idx) + '\n')
            f.write("Total number of iterations: " + str(self.number_of_iterations) + '\n')
            f.write("Total number of nodes explored: " + str(self.number_of_nodes) + '\n')
            f.write("Effective branching factor: " + str(self.calculate_eff_branching_factor()) + "\n")
            f.close()
        
        return self.paths
